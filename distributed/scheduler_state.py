import logging
import math
import operator
import uuid
from collections import defaultdict, deque
from collections.abc import Container, Iterable, Set
from functools import partial

from sortedcontainers import SortedDict, SortedSet
from tlz import merge_with

import dask
from dask.utils import format_bytes, parse_bytes, parse_timedelta
from dask.widgets import get_template

from distributed.utils import recursive_to_dict

from .active_memory_manager import ActiveMemoryManagerExtension
from .comm import get_address_host
from .core import Status
from .diagnostics.memory_sampler import MemorySamplerExtension
from .diagnostics.plugin import SchedulerPlugin, _get_plugin_name
from .event import EventExtension
from .lock import LockExtension
from .metrics import time
from .multi_lock import MultiLockExtension
from .publish import PublishExtension
from .pubsub import PubSubSchedulerExtension
from .queues import QueueExtension
from .recreate_tasks import ReplayTaskScheduler
from .semaphore import SemaphoreExtension
from .utils import key_split, key_split_group, log_errors
from .variable import VariableExtension

try:
    from cython import compiled
except ImportError:
    compiled = False

if compiled:
    from cython import (
        Py_hash_t,
        Py_ssize_t,
        bint,
        cast,
        ccall,
        cclass,
        cfunc,
        declare,
        double,
        exceptval,
        final,
        inline,
        nogil,
    )
else:
    from ctypes import c_double as double
    from ctypes import c_ssize_t as Py_hash_t
    from ctypes import c_ssize_t as Py_ssize_t

    bint = bool

    def cast(T, v, *a, **k):
        return v

    def ccall(func):
        return func

    def cclass(cls):
        return cls

    def cfunc(func):
        return func

    def declare(*a, **k):
        if len(a) == 2:
            return a[1]
        else:
            pass

    def exceptval(*a, **k):
        def wrapper(func):
            return func

        return wrapper

    def final(cls):
        return cls

    def inline(func):
        return func

    def nogil(func):
        return func


logger = logging.getLogger(__name__)


LOG_PDB = dask.config.get("distributed.admin.pdb-on-err")
DEFAULT_DATA_SIZE = declare(
    Py_ssize_t, parse_bytes(dask.config.get("distributed.scheduler.default-data-size"))
)

ALL_TASK_STATES = declare(
    set, {"released", "waiting", "no-worker", "processing", "erred", "memory"}
)
globals()["ALL_TASK_STATES"] = ALL_TASK_STATES
COMPILED = declare(bint, compiled)
globals()["COMPILED"] = COMPILED


@final
@cclass
class ClientState:
    """
    A simple object holding information about a client.

    .. attribute:: client_key: str

       A unique identifier for this client.  This is generally an opaque
       string generated by the client itself.

    .. attribute:: wants_what: {TaskState}

       A set of tasks this client wants kept in memory, so that it can
       download its result when desired.  This is the reverse mapping of
       :class:`TaskState.who_wants`.

       Tasks are typically removed from this set when the corresponding
       object in the client's space (for example a ``Future`` or a Dask
       collection) gets garbage-collected.

    """

    _client_key: str
    _hash: Py_hash_t
    _wants_what: set
    _last_seen: double
    _versions: dict

    __slots__ = ("_client_key", "_hash", "_wants_what", "_last_seen", "_versions")

    def __init__(self, client: str, versions: dict = None):
        self._client_key = client
        self._hash = hash(client)
        self._wants_what = set()
        self._last_seen = time()
        self._versions = versions or {}

    def __hash__(self):
        return self._hash

    def __eq__(self, other):
        typ_self: type = type(self)
        typ_other: type = type(other)
        if typ_self == typ_other:
            other_cs: ClientState = other
            return self._client_key == other_cs._client_key
        else:
            return False

    def __repr__(self):
        return "<Client '%s'>" % self._client_key

    def __str__(self):
        return self._client_key

    @property
    def client_key(self):
        return self._client_key

    @property
    def wants_what(self):
        return self._wants_what

    @property
    def last_seen(self):
        return self._last_seen

    @property
    def versions(self):
        return self._versions

    def _to_dict_no_nest(self, *, exclude: "Container[str]" = ()) -> dict:
        """Dictionary representation for debugging purposes.
        Not type stable and not intended for roundtrips.

        See also
        --------
        Client.dump_cluster_state
        distributed.utils.recursive_to_dict
        TaskState._to_dict
        """
        return recursive_to_dict(
            self,
            exclude=set(exclude) | {"versions"},  # type: ignore
            members=True,
        )


@final
@cclass
class MemoryState:
    """Memory readings on a worker or on the whole cluster.

    managed
        Sum of the output of sizeof() for all dask keys held by the worker in memory,
        plus number of bytes spilled to disk
    managed_in_memory
        Sum of the output of sizeof() for the dask keys held in RAM. Note that this may
        be inaccurate, which may cause inaccurate unmanaged memory (see below).
    managed_spilled
        Number of bytes  for the dask keys spilled to the hard drive.
        Note that this is the size on disk; size in memory may be different due to
        compression and inaccuracies in sizeof(). In other words, given the same keys,
        'managed' will change depending if the keys are in memory or spilled.
    process
        Total RSS memory measured by the OS on the worker process.
        This is always exactly equal to managed_in_memory + unmanaged.
    unmanaged
        process - managed_in_memory. This is the sum of

        - Python interpreter and modules
        - global variables
        - memory temporarily allocated by the dask tasks that are currently running
        - memory fragmentation
        - memory leaks
        - memory not yet garbage collected
        - memory not yet free()'d by the Python memory manager to the OS

    unmanaged_old
        Minimum of the 'unmanaged' measures over the last
        ``distributed.memory.recent-to-old-time`` seconds
    unmanaged_recent
        unmanaged - unmanaged_old; in other words process memory that has been recently
        allocated but is not accounted for by dask; hopefully it's mostly a temporary
        spike.
    optimistic
        managed_in_memory + unmanaged_old; in other words the memory held long-term by
        the process under the hopeful assumption that all unmanaged_recent memory is a
        temporary spike
    """

    __slots__ = ("_process", "_managed_in_memory", "_managed_spilled", "_unmanaged_old")

    _process: Py_ssize_t
    _managed_in_memory: Py_ssize_t
    _managed_spilled: Py_ssize_t
    _unmanaged_old: Py_ssize_t

    def __init__(
        self,
        *,
        process: Py_ssize_t,
        unmanaged_old: Py_ssize_t,
        managed_in_memory: Py_ssize_t,
        managed_spilled: Py_ssize_t,
    ):
        # Some data arrives with the heartbeat, some other arrives in realtime as the
        # tasks progress. Also, sizeof() is not guaranteed to return correct results.
        # This can cause glitches where a partial measure is larger than the whole, so
        # we need to force all numbers to add up exactly by definition.
        self._process = process
        self._managed_in_memory = min(self._process, managed_in_memory)
        self._managed_spilled = managed_spilled
        # Subtractions between unsigned ints guaranteed by construction to be >= 0
        self._unmanaged_old = min(unmanaged_old, process - self._managed_in_memory)

    @property
    def process(self) -> Py_ssize_t:
        return self._process

    @property
    def managed_in_memory(self) -> Py_ssize_t:
        return self._managed_in_memory

    @property
    def managed_spilled(self) -> Py_ssize_t:
        return self._managed_spilled

    @property
    def unmanaged_old(self) -> Py_ssize_t:
        return self._unmanaged_old

    @classmethod
    def sum(cls, *infos: "MemoryState") -> "MemoryState":
        process = 0
        unmanaged_old = 0
        managed_in_memory = 0
        managed_spilled = 0
        ms: MemoryState
        for ms in infos:
            process += ms._process
            unmanaged_old += ms._unmanaged_old
            managed_spilled += ms._managed_spilled
            managed_in_memory += ms._managed_in_memory
        return MemoryState(
            process=process,
            unmanaged_old=unmanaged_old,
            managed_in_memory=managed_in_memory,
            managed_spilled=managed_spilled,
        )

    @property
    def managed(self) -> Py_ssize_t:
        return self._managed_in_memory + self._managed_spilled

    @property
    def unmanaged(self) -> Py_ssize_t:
        # This is never negative thanks to __init__
        return self._process - self._managed_in_memory

    @property
    def unmanaged_recent(self) -> Py_ssize_t:
        # This is never negative thanks to __init__
        return self._process - self._managed_in_memory - self._unmanaged_old

    @property
    def optimistic(self) -> Py_ssize_t:
        return self._managed_in_memory + self._unmanaged_old

    def __repr__(self) -> str:
        return (
            f"Process memory (RSS)  : {format_bytes(self._process)}\n"
            f"  - managed by Dask   : {format_bytes(self._managed_in_memory)}\n"
            f"  - unmanaged (old)   : {format_bytes(self._unmanaged_old)}\n"
            f"  - unmanaged (recent): {format_bytes(self.unmanaged_recent)}\n"
            f"Spilled to disk       : {format_bytes(self._managed_spilled)}\n"
        )

    def _to_dict(self, *, exclude: "Container[str]" = ()) -> dict:
        """Dictionary representation for debugging purposes.
        Not type stable and not intended for roundtrips.

        See also
        --------
        Client.dump_cluster_state
        distributed.utils.recursive_to_dict
        """
        return recursive_to_dict(self, exclude=exclude, members=True)


@final
@cclass
class WorkerState:
    """
    A simple object holding information about a worker.

    .. attribute:: address: str

       This worker's unique key.  This can be its connected address
       (such as ``'tcp://127.0.0.1:8891'``) or an alias (such as ``'alice'``).

    .. attribute:: processing: {TaskState: cost}

       A dictionary of tasks that have been submitted to this worker.
       Each task state is associated with the expected cost in seconds
       of running that task, summing both the task's expected computation
       time and the expected communication time of its result.

       If a task is already executing on the worker and the excecution time is
       twice the learned average TaskGroup duration, this will be set to twice
       the current executing time. If the task is unknown, the default task
       duration is used instead of the TaskGroup average.

       Multiple tasks may be submitted to a worker in advance and the worker
       will run them eventually, depending on its execution resources
       (but see :doc:`work-stealing`).

       All the tasks here are in the "processing" state.

       This attribute is kept in sync with :attr:`TaskState.processing_on`.

    .. attribute:: executing: {TaskState: duration}

       A dictionary of tasks that are currently being run on this worker.
       Each task state is asssociated with the duration in seconds which
       the task has been running.

    .. attribute:: has_what: {TaskState}

       An insertion-sorted set-like of tasks which currently reside on this worker.
       All the tasks here are in the "memory" state.

       This is the reverse mapping of :class:`TaskState.who_has`.

    .. attribute:: nbytes: int

       The total memory size, in bytes, used by the tasks this worker
       holds in memory (i.e. the tasks in this worker's :attr:`has_what`).

    .. attribute:: nthreads: int

       The number of CPU threads made available on this worker.

    .. attribute:: resources: {str: Number}

       The available resources on this worker like ``{'gpu': 2}``.
       These are abstract quantities that constrain certain tasks from
       running at the same time on this worker.

    .. attribute:: used_resources: {str: Number}

       The sum of each resource used by all tasks allocated to this worker.
       The numbers in this dictionary can only be less or equal than
       those in this worker's :attr:`resources`.

    .. attribute:: occupancy: double

       The total expected runtime, in seconds, of all tasks currently
       processing on this worker.  This is the sum of all the costs in
       this worker's :attr:`processing` dictionary.

    .. attribute:: status: Status

       Read-only worker status, synced one way from the remote Worker object

    .. attribute:: nanny: str

       Address of the associated Nanny, if present

    .. attribute:: last_seen: Py_ssize_t

       The last time we received a heartbeat from this worker, in local
       scheduler time.

    .. attribute:: actors: {TaskState}

       A set of all TaskStates on this worker that are actors.  This only
       includes those actors whose state actually lives on this worker, not
       actors to which this worker has a reference.

    """

    # XXX need a state field to signal active/removed?

    _actors: set
    _address: str
    _bandwidth: double
    _executing: dict
    _extra: dict
    # _has_what is a dict with all values set to None as rebalance() relies on the
    # property of Python >=3.7 dicts to be insertion-sorted.
    _has_what: dict
    _hash: Py_hash_t
    _last_seen: double
    _local_directory: str
    _memory_limit: Py_ssize_t
    _memory_other_history: "deque[tuple[float, Py_ssize_t]]"
    _memory_unmanaged_old: Py_ssize_t
    _metrics: dict
    _name: object
    _nanny: str
    _nbytes: Py_ssize_t
    _nthreads: Py_ssize_t
    _occupancy: double
    _pid: Py_ssize_t
    _processing: dict
    _long_running: set
    _resources: dict
    _services: dict
    _status: Status
    _time_delay: double
    _used_resources: dict
    _versions: dict

    __slots__ = (
        "_actors",
        "_address",
        "_bandwidth",
        "_extra",
        "_executing",
        "_has_what",
        "_hash",
        "_last_seen",
        "_local_directory",
        "_memory_limit",
        "_memory_other_history",
        "_memory_unmanaged_old",
        "_metrics",
        "_name",
        "_nanny",
        "_nbytes",
        "_nthreads",
        "_occupancy",
        "_pid",
        "_processing",
        "_long_running",
        "_resources",
        "_services",
        "_status",
        "_time_delay",
        "_used_resources",
        "_versions",
    )

    def __init__(
        self,
        *,
        address: str,
        status: Status,
        pid: Py_ssize_t,
        name: object,
        nthreads: Py_ssize_t = 0,
        memory_limit: Py_ssize_t,
        local_directory: str,
        nanny: str,
        services: "dict | None" = None,
        versions: "dict | None" = None,
        extra: "dict | None" = None,
    ):
        self._address = address
        self._pid = pid
        self._name = name
        self._nthreads = nthreads
        self._memory_limit = memory_limit
        self._local_directory = local_directory
        self._services = services or {}
        self._versions = versions or {}
        self._nanny = nanny
        self._status = status

        self._hash = hash(address)
        self._nbytes = 0
        self._occupancy = 0
        self._memory_unmanaged_old = 0
        self._memory_other_history = deque()
        self._metrics = {}
        self._last_seen = 0
        self._time_delay = 0
        self._bandwidth = float(
            parse_bytes(dask.config.get("distributed.scheduler.bandwidth"))
        )

        self._actors = set()
        self._has_what = {}
        self._processing = {}
        self._long_running = set()
        self._executing = {}
        self._resources = {}
        self._used_resources = {}

        self._extra = extra or {}

    def __hash__(self):
        return self._hash

    def __eq__(self, other):
        typ_self: type = type(self)
        typ_other: type = type(other)
        if typ_self == typ_other:
            other_ws: WorkerState = other
            return self._address == other_ws._address
        else:
            return False

    @property
    def actors(self):
        return self._actors

    @property
    def address(self) -> str:
        return self._address

    @property
    def bandwidth(self):
        return self._bandwidth

    @property
    def executing(self):
        return self._executing

    @property
    def extra(self):
        return self._extra

    @property
    def has_what(self) -> "Set[TaskState]":
        return self._has_what.keys()

    @property
    def host(self):
        return get_address_host(self._address)

    @property
    def last_seen(self):
        return self._last_seen

    @property
    def local_directory(self):
        return self._local_directory

    @property
    def memory_limit(self):
        return self._memory_limit

    @property
    def metrics(self):
        return self._metrics

    @property
    def memory(self) -> MemoryState:
        return MemoryState(
            # metrics["memory"] is None if the worker sent a heartbeat before its
            # SystemMonitor ever had a chance to run
            process=self._metrics["memory"] or 0,
            # self._nbytes is instantaneous; metrics may lag behind by a heartbeat
            managed_in_memory=max(
                0, self._nbytes - self._metrics["spilled_nbytes"]["memory"]
            ),
            managed_spilled=self._metrics["spilled_nbytes"]["disk"],
            unmanaged_old=self._memory_unmanaged_old,
        )

    @property
    def name(self):
        return self._name

    @property
    def nanny(self):
        return self._nanny

    @property
    def nbytes(self):
        return self._nbytes

    @nbytes.setter
    def nbytes(self, v: Py_ssize_t):
        self._nbytes = v

    @property
    def nthreads(self):
        return self._nthreads

    @property
    def occupancy(self):
        return self._occupancy

    @occupancy.setter
    def occupancy(self, v: double):
        self._occupancy = v

    @property
    def pid(self):
        return self._pid

    @property
    def processing(self):
        return self._processing

    @property
    def resources(self):
        return self._resources

    @property
    def services(self):
        return self._services

    @property
    def status(self):
        return self._status

    @status.setter
    def status(self, new_status):
        if not isinstance(new_status, Status):
            raise TypeError(f"Expected Status; got {new_status!r}")
        self._status = new_status

    @property
    def time_delay(self):
        return self._time_delay

    @property
    def used_resources(self):
        return self._used_resources

    @property
    def versions(self):
        return self._versions

    @ccall
    def clean(self):
        """Return a version of this object that is appropriate for serialization"""
        ws: WorkerState = WorkerState(
            address=self._address,
            status=self._status,
            pid=self._pid,
            name=self._name,
            nthreads=self._nthreads,
            memory_limit=self._memory_limit,
            local_directory=self._local_directory,
            services=self._services,
            nanny=self._nanny,
            extra=self._extra,
        )
        ts: TaskState
        ws._processing = {ts._key: cost for ts, cost in self._processing.items()}
        ws._executing = {ts._key: duration for ts, duration in self._executing.items()}
        return ws

    def __repr__(self):
        name = f", name: {self.name}" if self.name != self.address else ""
        return (
            f"<WorkerState {self._address!r}{name}, "
            f"status: {self._status.name}, "
            f"memory: {len(self._has_what)}, "
            f"processing: {len(self._processing)}>"
        )

    def _repr_html_(self):
        return get_template("worker_state.html.j2").render(
            address=self.address,
            name=self.name,
            status=self.status.name,
            has_what=self._has_what,
            processing=self.processing,
        )

    @ccall
    @exceptval(check=False)
    def identity(self) -> dict:
        return {
            "type": "Worker",
            "id": self._name,
            "host": self.host,
            "resources": self._resources,
            "local_directory": self._local_directory,
            "name": self._name,
            "nthreads": self._nthreads,
            "memory_limit": self._memory_limit,
            "last_seen": self._last_seen,
            "services": self._services,
            "metrics": self._metrics,
            "nanny": self._nanny,
            **self._extra,
        }

    def _to_dict_no_nest(self, *, exclude: "Container[str]" = ()) -> dict:
        """Dictionary representation for debugging purposes.
        Not type stable and not intended for roundtrips.

        See also
        --------
        Client.dump_cluster_state
        distributed.utils.recursive_to_dict
        TaskState._to_dict
        """
        return recursive_to_dict(
            self,
            exclude=set(exclude) | {"versions"},  # type: ignore
            members=True,
        )


@final
@cclass
class Computation:
    """
    Collection tracking a single compute or persist call

    See also
    --------
    TaskPrefix
    TaskGroup
    TaskState
    """

    _start: double
    _groups: set
    _code: object
    _id: object

    def __init__(self):
        self._start = time()
        self._groups = set()
        self._code = SortedSet()
        self._id = uuid.uuid4()

    @property
    def code(self):
        return self._code

    @property
    def start(self):
        return self._start

    @property
    def stop(self):
        if self.groups:
            return max(tg.stop for tg in self.groups)
        else:
            return -1

    @property
    def states(self):
        tg: TaskGroup
        return merge_with(sum, [tg._states for tg in self._groups])

    @property
    def groups(self):
        return self._groups

    def __repr__(self):
        return (
            f"<Computation {self._id}: "
            + "Tasks: "
            + ", ".join(
                "%s: %d" % (k, v) for (k, v) in sorted(self.states.items()) if v
            )
            + ">"
        )

    def _repr_html_(self):
        return get_template("computation.html.j2").render(
            id=self._id,
            start=self.start,
            stop=self.stop,
            groups=self.groups,
            states=self.states,
            code=self.code,
        )


@final
@cclass
class TaskPrefix:
    """Collection tracking all tasks within a group

    Keys often have a structure like ``("x-123", 0)``
    A group takes the first section, like ``"x"``

    .. attribute:: name: str

       The name of a group of tasks.
       For a task like ``("x-123", 0)`` this is the text ``"x"``

    .. attribute:: states: Dict[str, int]

       The number of tasks in each state,
       like ``{"memory": 10, "processing": 3, "released": 4, ...}``

    .. attribute:: duration_average: float

       An exponentially weighted moving average duration of all tasks with this prefix

    .. attribute:: suspicious: int

       Numbers of times a task was marked as suspicious with this prefix


    See Also
    --------
    TaskGroup
    """

    _name: str
    _all_durations: "defaultdict[str, float]"
    _duration_average: double
    _suspicious: Py_ssize_t
    _groups: list

    def __init__(self, name: str):
        self._name = name
        self._groups = []

        # store timings for each prefix-action
        self._all_durations = defaultdict(float)

        task_durations = dask.config.get("distributed.scheduler.default-task-durations")
        if self._name in task_durations:
            self._duration_average = parse_timedelta(task_durations[self._name])
        else:
            self._duration_average = -1
        self._suspicious = 0

    @property
    def name(self) -> str:
        return self._name

    @property
    def all_durations(self) -> "defaultdict[str, float]":
        return self._all_durations

    @ccall
    @exceptval(check=False)
    def add_duration(self, action: str, start: double, stop: double):
        duration = stop - start
        self._all_durations[action] += duration
        if action == "compute":
            old = self._duration_average
            if old < 0:
                self._duration_average = duration
            else:
                self._duration_average = 0.5 * duration + 0.5 * old

    @property
    def duration_average(self) -> double:
        return self._duration_average

    @property
    def suspicious(self) -> Py_ssize_t:
        return self._suspicious

    @property
    def groups(self):
        return self._groups

    @property
    def states(self):
        tg: TaskGroup
        return merge_with(sum, [tg._states for tg in self._groups])

    @property
    def active(self) -> "list[TaskGroup]":
        tg: TaskGroup
        return [
            tg
            for tg in self._groups
            if any([v != 0 for k, v in tg._states.items() if k != "forgotten"])
        ]

    @property
    def active_states(self):
        tg: TaskGroup
        return merge_with(sum, [tg._states for tg in self.active])

    def __repr__(self):
        return (
            "<"
            + self._name
            + ": "
            + ", ".join(
                "%s: %d" % (k, v) for (k, v) in sorted(self.states.items()) if v
            )
            + ">"
        )

    @property
    def nbytes_total(self):
        tg: TaskGroup
        return sum([tg._nbytes_total for tg in self._groups])

    def __len__(self):
        return sum(map(len, self._groups))

    @property
    def duration(self):
        tg: TaskGroup
        return sum([tg._duration for tg in self._groups])

    @property
    def types(self):
        tg: TaskGroup
        return set().union(*[tg._types for tg in self._groups])


@final
@cclass
class TaskGroup:
    """Collection tracking all tasks within a group

    Keys often have a structure like ``("x-123", 0)``
    A group takes the first section, like ``"x-123"``

    .. attribute:: name: str

       The name of a group of tasks.
       For a task like ``("x-123", 0)`` this is the text ``"x-123"``

    .. attribute:: states: Dict[str, int]

       The number of tasks in each state,
       like ``{"memory": 10, "processing": 3, "released": 4, ...}``

    .. attribute:: dependencies: Set[TaskGroup]

       The other TaskGroups on which this one depends

    .. attribute:: nbytes_total: int

       The total number of bytes that this task group has produced

    .. attribute:: duration: float

       The total amount of time spent on all tasks in this TaskGroup

    .. attribute:: types: Set[str]

       The result types of this TaskGroup

    .. attribute:: last_worker: WorkerState

       The worker most recently assigned a task from this group, or None when the group
       is not identified to be root-like by `SchedulerState.decide_worker`.

    .. attribute:: last_worker_tasks_left: int

       If `last_worker` is not None, the number of times that worker should be assigned
       subsequent tasks until a new worker is chosen.

    See also
    --------
    TaskPrefix
    """

    _name: str
    _prefix: TaskPrefix  # TaskPrefix | None
    _states: dict
    _dependencies: set
    _nbytes_total: Py_ssize_t
    _duration: double
    _types: set
    _start: double
    _stop: double
    _all_durations: "defaultdict[str, float]"
    _last_worker: WorkerState  # WorkerState | None
    _last_worker_tasks_left: Py_ssize_t

    def __init__(self, name: str):
        self._name = name
        self._prefix = None  # type: ignore
        self._states = {state: 0 for state in ALL_TASK_STATES}
        self._states["forgotten"] = 0
        self._dependencies = set()
        self._nbytes_total = 0
        self._duration = 0
        self._types = set()
        self._start = 0.0
        self._stop = 0.0
        self._all_durations = defaultdict(float)
        self._last_worker = None  # type: ignore
        self._last_worker_tasks_left = 0

    @property
    def name(self) -> str:
        return self._name

    @property
    def prefix(self) -> "TaskPrefix | None":
        return self._prefix

    @property
    def states(self) -> dict:
        return self._states

    @property
    def dependencies(self) -> set:
        return self._dependencies

    @property
    def nbytes_total(self):
        return self._nbytes_total

    @property
    def duration(self) -> double:
        return self._duration

    @ccall
    @exceptval(check=False)
    def add_duration(self, action: str, start: double, stop: double):
        duration = stop - start
        self._all_durations[action] += duration
        if action == "compute":
            if self._stop < stop:
                self._stop = stop
            self._start = self._start or start
        self._duration += duration
        self._prefix.add_duration(action, start, stop)

    @property
    def types(self) -> set:
        return self._types

    @property
    def all_durations(self) -> "defaultdict[str, float]":
        return self._all_durations

    @property
    def start(self) -> double:
        return self._start

    @property
    def stop(self) -> double:
        return self._stop

    @property
    def last_worker(self) -> "WorkerState | None":
        return self._last_worker

    @property
    def last_worker_tasks_left(self) -> int:
        return self._last_worker_tasks_left

    @ccall
    def add(self, other: "TaskState"):
        self._states[other._state] += 1
        other._group = self

    def __repr__(self):
        return (
            "<"
            + (self._name or "no-group")
            + ": "
            + ", ".join(
                "%s: %d" % (k, v) for (k, v) in sorted(self._states.items()) if v
            )
            + ">"
        )

    def __len__(self):
        return sum(self._states.values())

    def _to_dict_no_nest(self, *, exclude: "Container[str]" = ()) -> dict:
        """Dictionary representation for debugging purposes.
        Not type stable and not intended for roundtrips.

        See also
        --------
        Client.dump_cluster_state
        distributed.utils.recursive_to_dict
        TaskState._to_dict
        """
        return recursive_to_dict(self, exclude=exclude, members=True)


@final
@cclass
class TaskState:
    """
    A simple object holding information about a task.

    .. attribute:: key: str

       The key is the unique identifier of a task, generally formed
       from the name of the function, followed by a hash of the function
       and arguments, like ``'inc-ab31c010444977004d656610d2d421ec'``.

    .. attribute:: prefix: TaskPrefix

       The broad class of tasks to which this task belongs like "inc" or
       "read_csv"

    .. attribute:: run_spec: object

       A specification of how to run the task.  The type and meaning of this
       value is opaque to the scheduler, as it is only interpreted by the
       worker to which the task is sent for executing.

       As a special case, this attribute may also be ``None``, in which case
       the task is "pure data" (such as, for example, a piece of data loaded
       in the scheduler using :meth:`Client.scatter`).  A "pure data" task
       cannot be computed again if its value is lost.

    .. attribute:: priority: tuple

       The priority provides each task with a relative ranking which is used
       to break ties when many tasks are being considered for execution.

       This ranking is generally a 2-item tuple.  The first (and dominant)
       item corresponds to when it was submitted.  Generally, earlier tasks
       take precedence.  The second item is determined by the client, and is
       a way to prioritize tasks within a large graph that may be important,
       such as if they are on the critical path, or good to run in order to
       release many dependencies.  This is explained further in
       :doc:`Scheduling Policy <scheduling-policies>`.

    .. attribute:: state: str

       This task's current state.  Valid states include ``released``,
       ``waiting``, ``no-worker``, ``processing``, ``memory``, ``erred``
       and ``forgotten``.  If it is ``forgotten``, the task isn't stored
       in the ``tasks`` dictionary anymore and will probably disappear
       soon from memory.

    .. attribute:: dependencies: {TaskState}

       The set of tasks this task depends on for proper execution.  Only
       tasks still alive are listed in this set.  If, for whatever reason,
       this task also depends on a forgotten task, the
       :attr:`has_lost_dependencies` flag is set.

       A task can only be executed once all its dependencies have already
       been successfully executed and have their result stored on at least
       one worker.  This is tracked by progressively draining the
       :attr:`waiting_on` set.

    .. attribute:: dependents: {TaskState}

       The set of tasks which depend on this task.  Only tasks still alive
       are listed in this set.

       This is the reverse mapping of :attr:`dependencies`.

    .. attribute:: has_lost_dependencies: bool

       Whether any of the dependencies of this task has been forgotten.
       For memory consumption reasons, forgotten tasks are not kept in
       memory even though they may have dependent tasks.  When a task is
       forgotten, therefore, each of its dependents has their
       :attr:`has_lost_dependencies` attribute set to ``True``.

       If :attr:`has_lost_dependencies` is true, this task cannot go
       into the "processing" state anymore.

    .. attribute:: waiting_on: {TaskState}

       The set of tasks this task is waiting on *before* it can be executed.
       This is always a subset of :attr:`dependencies`.  Each time one of the
       dependencies has finished processing, it is removed from the
       :attr:`waiting_on` set.

       Once :attr:`waiting_on` becomes empty, this task can move from the
       "waiting" state to the "processing" state (unless one of the
       dependencies errored out, in which case this task is instead
       marked "erred").

    .. attribute:: waiters: {TaskState}

       The set of tasks which need this task to remain alive.  This is always
       a subset of :attr:`dependents`.  Each time one of the dependents
       has finished processing, it is removed from the :attr:`waiters`
       set.

       Once both :attr:`waiters` and :attr:`who_wants` become empty, this
       task can be released (if it has a non-empty :attr:`run_spec`) or
       forgotten (otherwise) by the scheduler, and by any workers
       in :attr:`who_has`.

       .. note:: Counter-intuitively, :attr:`waiting_on` and
          :attr:`waiters` are not reverse mappings of each other.

    .. attribute:: who_wants: {ClientState}

       The set of clients who want this task's result to remain alive.
       This is the reverse mapping of :attr:`ClientState.wants_what`.

       When a client submits a graph to the scheduler it also specifies
       which output tasks it desires, such that their results are not released
       from memory.

       Once a task has finished executing (i.e. moves into the "memory"
       or "erred" state), the clients in :attr:`who_wants` are notified.

       Once both :attr:`waiters` and :attr:`who_wants` become empty, this
       task can be released (if it has a non-empty :attr:`run_spec`) or
       forgotten (otherwise) by the scheduler, and by any workers
       in :attr:`who_has`.

    .. attribute:: who_has: {WorkerState}

       The set of workers who have this task's result in memory.
       It is non-empty iff the task is in the "memory" state.  There can be
       more than one worker in this set if, for example, :meth:`Client.scatter`
       or :meth:`Client.replicate` was used.

       This is the reverse mapping of :attr:`WorkerState.has_what`.

    .. attribute:: processing_on: WorkerState (or None)

       If this task is in the "processing" state, which worker is currently
       processing it.  Otherwise this is ``None``.

       This attribute is kept in sync with :attr:`WorkerState.processing`.

    .. attribute:: retries: int

       The number of times this task can automatically be retried in case
       of failure.  If a task fails executing (the worker returns with
       an error), its :attr:`retries` attribute is checked.  If it is
       equal to 0, the task is marked "erred".  If it is greater than 0,
       the :attr:`retries` attribute is decremented and execution is
       attempted again.

    .. attribute:: nbytes: int (or None)

       The number of bytes, as determined by ``sizeof``, of the result
       of a finished task.  This number is used for diagnostics and to
       help prioritize work.

    .. attribute:: type: str

       The type of the object as a string.  Only present for tasks that have
       been computed.

    .. attribute:: exception: object

       If this task failed executing, the exception object is stored here.
       Otherwise this is ``None``.

    .. attribute:: traceback: object

       If this task failed executing, the traceback object is stored here.
       Otherwise this is ``None``.

    .. attribute:: exception_blame: TaskState (or None)

       If this task or one of its dependencies failed executing, the
       failed task is stored here (possibly itself).  Otherwise this
       is ``None``.

    .. attribute:: erred_on: set(str)

        Worker addresses on which errors appeared causing this task to be in an error state.

    .. attribute:: suspicious: int

       The number of times this task has been involved in a worker death.

       Some tasks may cause workers to die (such as calling ``os._exit(0)``).
       When a worker dies, all of the tasks on that worker are reassigned
       to others.  This combination of behaviors can cause a bad task to
       catastrophically destroy all workers on the cluster, one after
       another.  Whenever a worker dies, we mark each task currently
       processing on that worker (as recorded by
       :attr:`WorkerState.processing`) as suspicious.

       If a task is involved in three deaths (or some other fixed constant)
       then we mark the task as ``erred``.

    .. attribute:: host_restrictions: {hostnames}

       A set of hostnames where this task can be run (or ``None`` if empty).
       Usually this is empty unless the task has been specifically restricted
       to only run on certain hosts.  A hostname may correspond to one or
       several connected workers.

    .. attribute:: worker_restrictions: {worker addresses}

       A set of complete worker addresses where this can be run (or ``None``
       if empty).  Usually this is empty unless the task has been specifically
       restricted to only run on certain workers.

       Note this is tracking worker addresses, not worker states, since
       the specific workers may not be connected at this time.

    .. attribute:: resource_restrictions: {resource: quantity}

       Resources required by this task, such as ``{'gpu': 1}`` or
       ``{'memory': 1e9}`` (or ``None`` if empty).  These are user-defined
       names and are matched against the contents of each
       :attr:`WorkerState.resources` dictionary.

    .. attribute:: loose_restrictions: bool

       If ``False``, each of :attr:`host_restrictions`,
       :attr:`worker_restrictions` and :attr:`resource_restrictions` is
       a hard constraint: if no worker is available satisfying those
       restrictions, the task cannot go into the "processing" state and
       will instead go into the "no-worker" state.

       If ``True``, the above restrictions are mere preferences: if no worker
       is available satisfying those restrictions, the task can still go
       into the "processing" state and be sent for execution to another
       connected worker.

    .. attribute:: metadata: dict

       Metadata related to task.

    .. attribute:: actor: bool

       Whether or not this task is an Actor.

    .. attribute:: group: TaskGroup

        The group of tasks to which this one belongs.

    .. attribute:: annotations: dict

        Task annotations
    """

    _key: str
    _hash: Py_hash_t
    _prefix: TaskPrefix
    _run_spec: object
    _priority: tuple  # tuple | None
    _state: str  # str | None
    _dependencies: set  # set[TaskState]
    _dependents: set  # set[TaskState]
    _has_lost_dependencies: bint
    _waiting_on: set  # set[TaskState]
    _waiters: set  # set[TaskState]
    _who_wants: set  # set[ClientState]
    _who_has: set  # set[WorkerState]
    _processing_on: WorkerState  # WorkerState | None
    _retries: Py_ssize_t
    _nbytes: Py_ssize_t
    _type: str  # str | None
    _exception: object
    _exception_text: str
    _traceback: object
    _traceback_text: str
    _exception_blame: "TaskState"  # TaskState | None"
    _erred_on: set
    _suspicious: Py_ssize_t
    _host_restrictions: set  # set[str] | None
    _worker_restrictions: set  # set[str] | None
    _resource_restrictions: dict  # dict | None
    _loose_restrictions: bint
    _metadata: dict
    _annotations: dict
    _actor: bint
    _group: TaskGroup  # TaskGroup | None
    _group_key: str

    __slots__ = (
        # === General description ===
        "_actor",
        # Key name
        "_key",
        # Hash of the key name
        "_hash",
        # Key prefix (see key_split())
        "_prefix",
        # How to run the task (None if pure data)
        "_run_spec",
        # Alive dependents and dependencies
        "_dependencies",
        "_dependents",
        # Compute priority
        "_priority",
        # Restrictions
        "_host_restrictions",
        "_worker_restrictions",  # not WorkerStates but addresses
        "_resource_restrictions",
        "_loose_restrictions",
        # === Task state ===
        "_state",
        # Whether some dependencies were forgotten
        "_has_lost_dependencies",
        # If in 'waiting' state, which tasks need to complete
        # before we can run
        "_waiting_on",
        # If in 'waiting' or 'processing' state, which tasks needs us
        # to complete before they can run
        "_waiters",
        # In in 'processing' state, which worker we are processing on
        "_processing_on",
        # If in 'memory' state, Which workers have us
        "_who_has",
        # Which clients want us
        "_who_wants",
        "_exception",
        "_exception_text",
        "_traceback",
        "_traceback_text",
        "_erred_on",
        "_exception_blame",
        "_suspicious",
        "_retries",
        "_nbytes",
        "_type",
        "_group_key",
        "_group",
        "_metadata",
        "_annotations",
    )

    def __init__(self, key: str, run_spec: object):
        self._key = key
        self._hash = hash(key)
        self._run_spec = run_spec
        self._state = None  # type: ignore
        self._exception = None
        self._exception_blame = None  # type: ignore
        self._traceback = None
        self._exception_text = ""
        self._traceback_text = ""
        self._suspicious = 0
        self._retries = 0
        self._nbytes = -1
        self._priority = None  # type: ignore
        self._who_wants = set()
        self._dependencies = set()
        self._dependents = set()
        self._waiting_on = set()
        self._waiters = set()
        self._who_has = set()
        self._processing_on = None  # type: ignore
        self._has_lost_dependencies = False
        self._host_restrictions = None  # type: ignore
        self._worker_restrictions = None  # type: ignore
        self._resource_restrictions = None  # type: ignore
        self._loose_restrictions = False
        self._actor = False
        self._type = None  # type: ignore
        self._group_key = key_split_group(key)
        self._group = None  # type: ignore
        self._metadata = {}
        self._annotations = {}
        self._erred_on = set()

    def __hash__(self):
        return self._hash

    def __eq__(self, other):
        typ_self: type = type(self)
        typ_other: type = type(other)
        if typ_self == typ_other:
            other_ts: TaskState = other
            return self._key == other_ts._key
        else:
            return False

    @property
    def key(self):
        return self._key

    @property
    def prefix(self):
        return self._prefix

    @property
    def run_spec(self):
        return self._run_spec

    @property
    def priority(self) -> "tuple | None":
        return self._priority

    @property
    def state(self) -> "str | None":
        return self._state

    @state.setter
    def state(self, value: str):
        self._group._states[self._state] -= 1
        self._group._states[value] += 1
        self._state = value

    @property
    def dependencies(self) -> "set[TaskState]":
        return self._dependencies

    @property
    def dependents(self) -> "set[TaskState]":
        return self._dependents

    @property
    def has_lost_dependencies(self):
        return self._has_lost_dependencies

    @property
    def waiting_on(self) -> "set[TaskState]":
        return self._waiting_on

    @property
    def waiters(self) -> "set[TaskState]":
        return self._waiters

    @property
    def who_wants(self) -> "set[ClientState]":
        return self._who_wants

    @property
    def who_has(self) -> "set[WorkerState]":
        return self._who_has

    @property
    def processing_on(self) -> "WorkerState | None":
        return self._processing_on

    @processing_on.setter
    def processing_on(self, v: WorkerState) -> None:
        self._processing_on = v

    @property
    def retries(self):
        return self._retries

    @property
    def nbytes(self):
        return self._nbytes

    @nbytes.setter
    def nbytes(self, v: Py_ssize_t):
        self._nbytes = v

    @property
    def type(self) -> "str | None":
        return self._type

    @property
    def exception(self):
        return self._exception

    @property
    def exception_text(self):
        return self._exception_text

    @property
    def traceback(self):
        return self._traceback

    @property
    def traceback_text(self):
        return self._traceback_text

    @property
    def exception_blame(self) -> "TaskState | None":
        return self._exception_blame

    @property
    def suspicious(self):
        return self._suspicious

    @property
    def host_restrictions(self) -> "set[str] | None":
        return self._host_restrictions

    @property
    def worker_restrictions(self) -> "set[str] | None":
        return self._worker_restrictions

    @property
    def resource_restrictions(self) -> "dict | None":
        return self._resource_restrictions

    @property
    def loose_restrictions(self):
        return self._loose_restrictions

    @property
    def metadata(self):
        return self._metadata

    @property
    def annotations(self):
        return self._annotations

    @property
    def actor(self):
        return self._actor

    @property
    def group(self) -> "TaskGroup | None":
        return self._group

    @property
    def group_key(self) -> str:
        return self._group_key

    @property
    def prefix_key(self):
        return self._prefix._name

    @property
    def erred_on(self):
        return self._erred_on

    @ccall
    def add_dependency(self, other: "TaskState"):
        """Add another task as a dependency of this task"""
        self._dependencies.add(other)
        self._group._dependencies.add(other._group)
        other._dependents.add(self)

    @ccall
    @inline
    @nogil
    def get_nbytes(self) -> Py_ssize_t:
        return self._nbytes if self._nbytes >= 0 else DEFAULT_DATA_SIZE

    @ccall
    def set_nbytes(self, nbytes: Py_ssize_t):
        diff: Py_ssize_t = nbytes
        old_nbytes: Py_ssize_t = self._nbytes
        if old_nbytes >= 0:
            diff -= old_nbytes
        self._group._nbytes_total += diff
        ws: WorkerState
        for ws in self._who_has:
            ws._nbytes += diff
        self._nbytes = nbytes

    def __repr__(self):
        return f"<TaskState {self._key!r} {self._state}>"

    def _repr_html_(self):
        return get_template("task_state.html.j2").render(
            state=self._state,
            nbytes=self._nbytes,
            key=self._key,
        )

    @ccall
    def validate(self):
        try:
            for cs in self._who_wants:
                assert isinstance(cs, ClientState), (repr(cs), self._who_wants)
            for ws in self._who_has:
                assert isinstance(ws, WorkerState), (repr(ws), self._who_has)
            for ts in self._dependencies:
                assert isinstance(ts, TaskState), (repr(ts), self._dependencies)
            for ts in self._dependents:
                assert isinstance(ts, TaskState), (repr(ts), self._dependents)
            validate_task_state(self)
        except Exception as e:
            logger.exception(e)
            if LOG_PDB:
                import pdb

                pdb.set_trace()

    def get_nbytes_deps(self):
        nbytes: Py_ssize_t = 0
        ts: TaskState
        for ts in self._dependencies:
            nbytes += ts.get_nbytes()
        return nbytes

    def _to_dict_no_nest(self, *, exclude: "Container[str]" = ()) -> dict:
        """Dictionary representation for debugging purposes.
        Not type stable and not intended for roundtrips.

        See also
        --------
        Client.dump_cluster_state
        distributed.utils.recursive_to_dict

        Notes
        -----
        This class uses ``_to_dict_no_nest`` instead of ``_to_dict``.
        When a task references another task, or when a WorkerState.tasks contains tasks,
        this method is not executed for the inner task, even if the inner task was never
        seen before; you get a repr instead. All tasks should neatly appear under
        Scheduler.tasks. This also prevents a RecursionError during particularly heavy
        loads, which have been observed to happen whenever there's an acyclic dependency
        chain of ~200+ tasks.
        """
        return recursive_to_dict(self, exclude=exclude, members=True)


@final
@cclass
class SchedulerState:
    """Underlying task state of dynamic scheduler

    Tracks the current state of workers, data, and computations.

    Handles transitions between different task states. Notifies the
    Scheduler of changes by messaging passing through Queues, which the
    Scheduler listens to responds accordingly.

    All events are handled quickly, in linear time with respect to their
    input (which is often of constant size) and generally within a
    millisecond. Additionally when Cythonized, this can be faster still.
    To accomplish this the scheduler tracks a lot of state.  Every
    operation maintains the consistency of this state.

    Users typically do not interact with ``Transitions`` directly. Instead
    users interact with the ``Client``, which in turn engages the
    ``Scheduler`` affecting different transitions here under-the-hood. In
    the background ``Worker``s also engage with the ``Scheduler``
    affecting these state transitions as well.

    **State**

    The ``Transitions`` object contains the following state variables.
    Each variable is listed along with what it stores and a brief
    description.

    * **tasks:** ``{task key: TaskState}``
        Tasks currently known to the scheduler
    * **unrunnable:** ``{TaskState}``
        Tasks in the "no-worker" state

    * **workers:** ``{worker key: WorkerState}``
        Workers currently connected to the scheduler
    * **idle:** ``{WorkerState}``:
        Set of workers that are not fully utilized
    * **saturated:** ``{WorkerState}``:
        Set of workers that are not over-utilized
    * **running:** ``{WorkerState}``:
        Set of workers that are currently in running state

    * **clients:** ``{client key: ClientState}``
        Clients currently connected to the scheduler

    * **task_duration:** ``{key-prefix: time}``
        Time we expect certain functions to take, e.g. ``{'sum': 0.25}``
    """

    _aliases: dict
    _bandwidth: double
    _clients: dict  # dict[str, ClientState]
    _computations: object
    _extensions: dict
    _host_info: dict
    _idle: "SortedDict[str, WorkerState]"
    _idle_dv: dict  # dict[str, WorkerState]
    _n_tasks: Py_ssize_t
    _resources: dict
    _saturated: set  # set[WorkerState]
    _running: set  # set[WorkerState]
    _tasks: dict
    _task_groups: dict
    _task_prefixes: dict
    _task_metadata: dict
    _replicated_tasks: set
    _total_nthreads: Py_ssize_t
    _total_occupancy: double
    _transition_log: deque
    _transitions_table: dict
    _unknown_durations: dict
    _unrunnable: set
    _validate: bint
    _workers: "SortedDict[str, WorkerState]"
    _workers_dv: dict  # dict[str, WorkerState]
    _transition_counter: Py_ssize_t
    _plugins: dict  # dict[str, SchedulerPlugin]

    # Pulled from dask.config for efficient usage
    _UNKNOWN_TASK_DURATION: double

    def __init__(
        self,
        aliases: dict,
        clients: "dict[str, ClientState]",
        workers: "SortedDict[str, WorkerState]",
        host_info: dict,
        resources: dict,
        tasks: dict,
        unrunnable: set,
        validate: bint,
        plugins: "Iterable[SchedulerPlugin]" = (),
        **kwargs,  # Passed verbatim to Server.__init__()
    ):
        self._aliases = aliases
        self._bandwidth = parse_bytes(
            dask.config.get("distributed.scheduler.bandwidth")
        )
        self._clients = clients
        self._clients["fire-and-forget"] = ClientState("fire-and-forget")
        self._extensions = {}
        self._host_info = host_info
        self._idle = SortedDict()
        # Note: cython.cast, not typing.cast!
        self._idle_dv = cast(dict, self._idle)
        self._n_tasks = 0
        self._resources = resources
        self._saturated = set()
        self._tasks = tasks
        self._replicated_tasks = {
            ts for ts in self._tasks.values() if len(ts._who_has) > 1
        }
        self._computations = deque(
            maxlen=dask.config.get("distributed.diagnostics.computations.max-history")
        )
        self._task_groups = {}
        self._task_prefixes = {}
        self._task_metadata = {}
        self._total_nthreads = 0
        self._total_occupancy = 0
        self._transition_log = deque(
            maxlen=dask.config.get("distributed.scheduler.transition-log-length")
        )
        self._transitions_table = {
            ("released", "waiting"): self.transition_released_waiting,
            ("waiting", "released"): self.transition_waiting_released,
            ("waiting", "processing"): self.transition_waiting_processing,
            ("waiting", "memory"): self.transition_waiting_memory,
            ("processing", "released"): self.transition_processing_released,
            ("processing", "memory"): self.transition_processing_memory,
            ("processing", "erred"): self.transition_processing_erred,
            ("no-worker", "released"): self.transition_no_worker_released,
            ("no-worker", "waiting"): self.transition_no_worker_waiting,
            ("no-worker", "memory"): self.transition_no_worker_memory,
            ("released", "forgotten"): self.transition_released_forgotten,
            ("memory", "forgotten"): self.transition_memory_forgotten,
            ("erred", "released"): self.transition_erred_released,
            ("memory", "released"): self.transition_memory_released,
            ("released", "erred"): self.transition_released_erred,
        }
        self._unknown_durations = {}
        self._unrunnable = unrunnable
        self._validate = validate
        self._workers = workers
        # Note: cython.cast, not typing.cast!
        self._workers_dv = cast(dict, self._workers)
        self._running = {
            ws for ws in self._workers.values() if ws.status == Status.running
        }
        self._plugins = {} if not plugins else {_get_plugin_name(p): p for p in plugins}

        # Pulled from dask.config for efficient usage
        self._UNKNOWN_TASK_DURATION = parse_timedelta(
            dask.config.get("distributed.scheduler.unknown-task-duration")
        )
        self._transition_counter = 0

        # Call Server.__init__()
        super().__init__(**kwargs)  # type: ignore

    @property
    def aliases(self):
        return self._aliases

    @property
    def bandwidth(self):
        return self._bandwidth

    @bandwidth.setter
    def bandwidth(self, v: double):
        self._bandwidth = v

    @property
    def clients(self):
        return self._clients

    @property
    def computations(self):
        return self._computations

    @property
    def extensions(self):
        return self._extensions

    @property
    def host_info(self):
        return self._host_info

    @property
    def idle(self):
        return self._idle

    @property
    def n_tasks(self):
        return self._n_tasks

    @property
    def resources(self):
        return self._resources

    @property
    def saturated(self) -> "set[WorkerState]":
        return self._saturated

    @property
    def running(self) -> "set[WorkerState]":
        return self._running

    @property
    def tasks(self):
        return self._tasks

    @property
    def task_groups(self):
        return self._task_groups

    @property
    def task_prefixes(self):
        return self._task_prefixes

    @property
    def task_metadata(self):
        return self._task_metadata

    @property
    def replicated_tasks(self):
        return self._replicated_tasks

    @property
    def total_nthreads(self):
        return self._total_nthreads

    @total_nthreads.setter
    def total_nthreads(self, v: Py_ssize_t):
        self._total_nthreads = v

    @property
    def total_occupancy(self):
        return self._total_occupancy

    @total_occupancy.setter
    def total_occupancy(self, v: double):
        self._total_occupancy = v

    @property
    def transition_log(self):
        return self._transition_log

    @property
    def transition_counter(self):
        return self._transition_counter

    @property
    def unknown_durations(self):
        return self._unknown_durations

    @property
    def unrunnable(self):
        return self._unrunnable

    @property
    def validate(self):
        return self._validate

    @validate.setter
    def validate(self, v: bint):
        self._validate = v

    @property
    def workers(self):
        return self._workers

    @property
    def plugins(self) -> "dict[str, SchedulerPlugin]":
        return self._plugins

    @plugins.setter
    def plugins(self, val):
        self._plugins = val

    @property
    def memory(self) -> MemoryState:
        return MemoryState.sum(*(w.memory for w in self.workers.values()))

    @property
    def __pdict__(self):
        return {
            "bandwidth": self._bandwidth,
            "resources": self._resources,
            "saturated": self._saturated,
            "unrunnable": self._unrunnable,
            "n_tasks": self._n_tasks,
            "unknown_durations": self._unknown_durations,
            "validate": self._validate,
            "tasks": self._tasks,
            "task_groups": self._task_groups,
            "task_prefixes": self._task_prefixes,
            "total_nthreads": self._total_nthreads,
            "total_occupancy": self._total_occupancy,
            "extensions": self._extensions,
            "clients": self._clients,
            "workers": self._workers,
            "idle": self._idle,
            "host_info": self._host_info,
        }

    @ccall
    @exceptval(check=False)
    def new_task(
        self, key: str, spec: object, state: str, computation: Computation = None
    ) -> TaskState:
        """Create a new task, and associated states"""
        ts: TaskState = TaskState(key, spec)
        ts._state = state

        tp: TaskPrefix
        prefix_key = key_split(key)
        tp = self._task_prefixes.get(prefix_key)  # type: ignore
        if tp is None:
            self._task_prefixes[prefix_key] = tp = TaskPrefix(prefix_key)
        ts._prefix = tp

        group_key = ts._group_key
        tg: TaskGroup = self._task_groups.get(group_key)  # type: ignore
        if tg is None:
            self._task_groups[group_key] = tg = TaskGroup(group_key)
            if computation:
                computation.groups.add(tg)
            tg._prefix = tp
            tp._groups.append(tg)
        tg.add(ts)

        self._tasks[key] = ts

        return ts

    #####################
    # State Transitions #
    #####################

    @ccall
    def transition(self, key, finish: str, args: tuple = None, kwargs: dict = None):
        """Transition a key from its current state to the finish state

        Examples.stimulus_task_finished
        --------
        >>> self.transition('x', 'waiting')
        {'x': 'processing'}

        Returns
        -------
        Dictionary of recommendations for future transitions

        See Also
        --------
        Scheduler.transitions : transitive version of this function
        """
        ts: TaskState
        start: str
        start_finish: tuple
        finish2: str
        recommendations: dict
        worker_msgs: dict
        client_msgs: dict
        msgs: list
        new_msgs: list
        dependents: set
        dependencies: set
        args = args or ()
        kwargs = kwargs or {}
        try:
            recommendations = {}
            worker_msgs = {}
            client_msgs = {}

            ts = self._tasks.get(key)  # type: ignore
            if ts is None:
                return recommendations, client_msgs, worker_msgs
            start = ts._state
            if start == finish:
                return recommendations, client_msgs, worker_msgs

            if self.plugins:
                dependents = set(ts._dependents)
                dependencies = set(ts._dependencies)

            start_finish = (start, finish)
            func = self._transitions_table.get(start_finish)
            if func is not None:
                recommendations, client_msgs, worker_msgs = func(key, *args, **kwargs)
                self._transition_counter += 1
            elif "released" not in start_finish:
                assert not args and not kwargs, (args, kwargs, start_finish)
                a_recs: dict
                a_cmsgs: dict
                a_wmsgs: dict
                a: tuple = self.transition(key, "released")
                a_recs, a_cmsgs, a_wmsgs = a

                v = a_recs.get(key, finish)
                func = self._transitions_table["released", v]
                b_recs: dict
                b_cmsgs: dict
                b_wmsgs: dict
                b: tuple = func(key)
                b_recs, b_cmsgs, b_wmsgs = b

                recommendations.update(a_recs)
                for c, new_msgs in a_cmsgs.items():
                    msgs = client_msgs.get(c)  # type: ignore
                    if msgs is not None:
                        msgs.extend(new_msgs)
                    else:
                        client_msgs[c] = new_msgs
                for w, new_msgs in a_wmsgs.items():
                    msgs = worker_msgs.get(w)  # type: ignore
                    if msgs is not None:
                        msgs.extend(new_msgs)
                    else:
                        worker_msgs[w] = new_msgs

                recommendations.update(b_recs)
                for c, new_msgs in b_cmsgs.items():
                    msgs = client_msgs.get(c)  # type: ignore
                    if msgs is not None:
                        msgs.extend(new_msgs)
                    else:
                        client_msgs[c] = new_msgs
                for w, new_msgs in b_wmsgs.items():
                    msgs = worker_msgs.get(w)  # type: ignore
                    if msgs is not None:
                        msgs.extend(new_msgs)
                    else:
                        worker_msgs[w] = new_msgs

                start = "released"
            else:
                raise RuntimeError("Impossible transition from %r to %r" % start_finish)

            finish2 = ts._state
            self._transition_log.append((key, start, finish2, recommendations, time()))
            if self._validate:
                logger.debug(
                    "Transitioned %r %s->%s (actual: %s).  Consequence: %s",
                    key,
                    start,
                    finish2,
                    ts._state,
                    dict(recommendations),
                )
            if self.plugins:
                # Temporarily put back forgotten key for plugin to retrieve it
                if ts._state == "forgotten":
                    ts._dependents = dependents
                    ts._dependencies = dependencies
                    self._tasks[ts._key] = ts
                for plugin in list(self.plugins.values()):
                    try:
                        plugin.transition(key, start, finish2, *args, **kwargs)
                    except Exception:
                        logger.info("Plugin failed with exception", exc_info=True)
                if ts._state == "forgotten":
                    del self._tasks[ts._key]

            tg: TaskGroup = ts._group
            if ts._state == "forgotten" and tg._name in self._task_groups:
                # Remove TaskGroup if all tasks are in the forgotten state
                all_forgotten: bint = True
                for s in ALL_TASK_STATES:
                    if tg._states.get(s):
                        all_forgotten = False
                        break
                if all_forgotten:
                    ts._prefix._groups.remove(tg)
                    del self._task_groups[tg._name]

            return recommendations, client_msgs, worker_msgs
        except Exception:
            logger.exception("Error transitioning %r from %r to %r", key, start, finish)
            if LOG_PDB:
                import pdb

                pdb.set_trace()
            raise

    @ccall
    def transitions(self, recommendations: dict, client_msgs: dict, worker_msgs: dict):
        """Process transitions until none are left

        This includes feedback from previous transitions and continues until we
        reach a steady state
        """
        keys: set = set()
        recommendations = recommendations.copy()
        msgs: list
        new_msgs: list
        new: tuple
        new_recs: dict
        new_cmsgs: dict
        new_wmsgs: dict
        while recommendations:
            key, finish = recommendations.popitem()
            keys.add(key)

            new = self.transition(key, finish)
            new_recs, new_cmsgs, new_wmsgs = new

            recommendations.update(new_recs)
            for c, new_msgs in new_cmsgs.items():
                msgs = client_msgs.get(c)  # type: ignore
                if msgs is not None:
                    msgs.extend(new_msgs)
                else:
                    client_msgs[c] = new_msgs
            for w, new_msgs in new_wmsgs.items():
                msgs = worker_msgs.get(w)  # type: ignore
                if msgs is not None:
                    msgs.extend(new_msgs)
                else:
                    worker_msgs[w] = new_msgs

        if self._validate:
            for key in keys:
                self.validate_key(key)

    def transition_released_waiting(self, key):
        try:
            ts: TaskState = self._tasks[key]
            dts: TaskState
            recommendations: dict = {}
            client_msgs: dict = {}
            worker_msgs: dict = {}

            if self._validate:
                assert ts._run_spec
                assert not ts._waiting_on
                assert not ts._who_has
                assert not ts._processing_on
                assert not any([dts._state == "forgotten" for dts in ts._dependencies])

            if ts._has_lost_dependencies:
                recommendations[key] = "forgotten"
                return recommendations, client_msgs, worker_msgs

            ts.state = "waiting"

            dts: TaskState
            for dts in ts._dependencies:
                if dts._exception_blame:
                    ts._exception_blame = dts._exception_blame
                    recommendations[key] = "erred"
                    return recommendations, client_msgs, worker_msgs

            for dts in ts._dependencies:
                dep = dts._key
                if not dts._who_has:
                    ts._waiting_on.add(dts)
                if dts._state == "released":
                    recommendations[dep] = "waiting"
                else:
                    dts._waiters.add(ts)

            ts._waiters = {dts for dts in ts._dependents if dts._state == "waiting"}

            if not ts._waiting_on:
                if self._workers_dv:
                    recommendations[key] = "processing"
                else:
                    self._unrunnable.add(ts)
                    ts.state = "no-worker"

            return recommendations, client_msgs, worker_msgs
        except Exception as e:
            logger.exception(e)
            if LOG_PDB:
                import pdb

                pdb.set_trace()
            raise

    def transition_no_worker_waiting(self, key):
        try:
            ts: TaskState = self._tasks[key]
            dts: TaskState
            recommendations: dict = {}
            client_msgs: dict = {}
            worker_msgs: dict = {}

            if self._validate:
                assert ts in self._unrunnable
                assert not ts._waiting_on
                assert not ts._who_has
                assert not ts._processing_on

            self._unrunnable.remove(ts)

            if ts._has_lost_dependencies:
                recommendations[key] = "forgotten"
                return recommendations, client_msgs, worker_msgs

            for dts in ts._dependencies:
                dep = dts._key
                if not dts._who_has:
                    ts._waiting_on.add(dts)
                if dts._state == "released":
                    recommendations[dep] = "waiting"
                else:
                    dts._waiters.add(ts)

            ts.state = "waiting"

            if not ts._waiting_on:
                if self._workers_dv:
                    recommendations[key] = "processing"
                else:
                    self._unrunnable.add(ts)
                    ts.state = "no-worker"

            return recommendations, client_msgs, worker_msgs
        except Exception as e:
            logger.exception(e)
            if LOG_PDB:
                import pdb

                pdb.set_trace()
            raise

    def transition_no_worker_memory(
        self, key, nbytes=None, type=None, typename: str = None, worker=None
    ):
        try:
            ws: WorkerState = self._workers_dv[worker]
            ts: TaskState = self._tasks[key]
            recommendations: dict = {}
            client_msgs: dict = {}
            worker_msgs: dict = {}

            if self._validate:
                assert not ts._processing_on
                assert not ts._waiting_on
                assert ts._state == "no-worker"

            self._unrunnable.remove(ts)

            if nbytes is not None:
                ts.set_nbytes(nbytes)

            self.check_idle_saturated(ws)

            self._add_to_memory(
                ts, ws, recommendations, client_msgs, type=type, typename=typename
            )
            ts.state = "memory"

            return recommendations, client_msgs, worker_msgs
        except Exception as e:
            logger.exception(e)
            if LOG_PDB:
                import pdb

                pdb.set_trace()
            raise

    # Utility methods related to transitions

    @cfunc
    @exceptval(check=False)
    def _remove_from_processing(self, ts: TaskState) -> str:  # -> str | None
        """
        Remove *ts* from the set of processing tasks.

        See also ``Scheduler.set_duration_estimate``
        """
        ws: WorkerState = ts._processing_on
        ts._processing_on = None  # type: ignore
        w: str = ws._address

        if w not in self._workers_dv:  # may have been removed
            return None  # type: ignore

        duration: double = ws._processing.pop(ts)
        if not ws._processing:
            self._total_occupancy -= ws._occupancy
            ws._occupancy = 0
        else:
            self._total_occupancy -= duration
            ws._occupancy -= duration

        self.check_idle_saturated(ws)
        self.release_resources(ts, ws)

        return w

    @cfunc
    @exceptval(check=False)
    def _add_to_memory(
        self,
        ts: TaskState,
        ws: WorkerState,
        recommendations: dict,
        client_msgs: dict,
        type=None,
        typename: str = None,
    ):
        """
        Add *ts* to the set of in-memory tasks.
        """
        if self._validate:
            assert ts not in ws._has_what

        self.add_replica(ts, ws)

        deps: list = list(ts._dependents)
        if len(deps) > 1:
            deps.sort(key=operator.attrgetter("priority"), reverse=True)

        dts: TaskState
        s: set
        for dts in deps:
            s = dts._waiting_on
            if ts in s:
                s.discard(ts)
                if not s:  # new task ready to run
                    recommendations[dts._key] = "processing"

        for dts in ts._dependencies:
            s = dts._waiters
            s.discard(ts)
            if not s and not dts._who_wants:
                recommendations[dts._key] = "released"

        report_msg: dict = {}
        cs: ClientState
        if not ts._waiters and not ts._who_wants:
            recommendations[ts._key] = "released"
        else:
            report_msg["op"] = "key-in-memory"
            report_msg["key"] = ts._key
            if type is not None:
                report_msg["type"] = type

            for cs in ts._who_wants:
                client_msgs[cs._client_key] = [report_msg]

        ts.state = "memory"
        ts._type = typename  # type: ignore
        ts._group._types.add(typename)

        cs = self._clients["fire-and-forget"]
        if ts in cs._wants_what:
            self._client_releases_keys(
                cs=cs,
                keys=[ts._key],
                recommendations=recommendations,
            )

    @cfunc
    @exceptval(check=False)
    def _propagate_forgotten(
        self, ts: TaskState, recommendations: dict, worker_msgs: dict
    ):
        ts.state = "forgotten"
        key: str = ts._key
        dts: TaskState
        for dts in ts._dependents:
            dts._has_lost_dependencies = True
            dts._dependencies.remove(ts)
            dts._waiting_on.discard(ts)
            if dts._state not in ("memory", "erred"):
                # Cannot compute task anymore
                recommendations[dts._key] = "forgotten"
        ts._dependents.clear()
        ts._waiters.clear()

        for dts in ts._dependencies:
            dts._dependents.remove(ts)
            dts._waiters.discard(ts)
            if not dts._dependents and not dts._who_wants:
                # Task not needed anymore
                assert dts is not ts
                recommendations[dts._key] = "forgotten"
        ts._dependencies.clear()
        ts._waiting_on.clear()

        ws: WorkerState
        for ws in ts._who_has:
            w: str = ws._address
            if w in self._workers_dv:  # in case worker has died
                worker_msgs[w] = [
                    {
                        "op": "free-keys",
                        "keys": [key],
                        "stimulus_id": f"propagate-forgotten-{time()}",
                    }
                ]
        self.remove_all_replicas(ts)

    @ccall
    @exceptval(check=False)
    def _client_releases_keys(self, keys: list, cs: ClientState, recommendations: dict):
        """Remove keys from client desired list"""
        logger.debug("Client %s releases keys: %s", cs._client_key, keys)
        ts: TaskState
        for key in keys:
            ts = self._tasks.get(key)  # type: ignore
            if ts is not None and ts in cs._wants_what:
                cs._wants_what.remove(ts)
                ts._who_wants.remove(cs)
                if not ts._who_wants:
                    if not ts._dependents:
                        # No live dependents, can forget
                        recommendations[ts._key] = "forgotten"
                    elif ts._state != "erred" and not ts._waiters:
                        recommendations[ts._key] = "released"

    # Message building functions for communication

    @ccall
    @exceptval(check=False)
    def _task_to_msg(self, ts: TaskState, duration: double = -1) -> dict:
        """Convert a single computational task to a message"""
        ws: WorkerState
        dts: TaskState

        # FIXME: The duration attribute is not used on worker. We could safe ourselves the time to compute and submit this
        if duration < 0:
            duration = self.get_task_duration(ts)

        msg: dict = {
            "op": "compute-task",
            "key": ts._key,
            "priority": ts._priority,
            "duration": duration,
            "stimulus_id": f"compute-task-{time()}",
            "who_has": {},
        }
        if ts._resource_restrictions:
            msg["resource_restrictions"] = ts._resource_restrictions
        if ts._actor:
            msg["actor"] = True

        deps: set = ts._dependencies
        if deps:
            msg["who_has"] = {
                dts._key: [ws._address for ws in dts._who_has] for dts in deps
            }
            msg["nbytes"] = {dts._key: dts._nbytes for dts in deps}

            if self._validate:
                assert all(msg["who_has"].values())

        task = ts._run_spec
        if type(task) is dict:
            msg.update(task)
        else:
            msg["task"] = task

        if ts._annotations:
            msg["annotations"] = ts._annotations

        return msg

    @ccall
    @exceptval(check=False)
    def _task_to_report_msg(self, ts: TaskState) -> dict:  # -> dict | None
        if ts._state == "forgotten":
            return {"op": "cancelled-key", "key": ts._key}
        elif ts._state == "memory":
            return {"op": "key-in-memory", "key": ts._key}
        elif ts._state == "erred":
            failing_ts: TaskState = ts._exception_blame
            return {
                "op": "task-erred",
                "key": ts._key,
                "exception": failing_ts._exception,
                "traceback": failing_ts._traceback,
            }
        else:
            return None  # type: ignore

    @cfunc
    @exceptval(check=False)
    def _task_to_client_msgs(self, ts: TaskState) -> dict:
        if ts._who_wants:
            report_msg: dict = self._task_to_report_msg(ts)
            if report_msg is not None:
                cs: ClientState
                return {cs._client_key: [report_msg] for cs in ts._who_wants}
        return {}

    # Other transition related functions

    @ccall
    @exceptval(check=False)
    def decide_worker(self, ts: TaskState) -> WorkerState:  # -> WorkerState | None
        """
        Decide on a worker for task *ts*. Return a WorkerState.

        If it's a root or root-like task, we place it with its relatives to
        reduce future data tansfer.

        If it has dependencies or restrictions, we use
        `decide_worker_from_deps_and_restrictions`.

        Otherwise, we pick the least occupied worker, or pick from all workers
        in a round-robin fashion.
        """
        if not self._workers_dv:
            return None  # type: ignore

        ws: WorkerState
        tg: TaskGroup = ts._group
        valid_workers: set = self.valid_workers(ts)

        if (
            valid_workers is not None
            and not valid_workers
            and not ts._loose_restrictions
        ):
            self._unrunnable.add(ts)
            ts.state = "no-worker"
            return None  # type: ignore

        # Group is larger than cluster with few dependencies?
        # Minimize future data transfers.
        if (
            valid_workers is None
            and len(tg) > self._total_nthreads * 2
            and len(tg._dependencies) < 5
            and sum(map(len, tg._dependencies)) < 5
        ):
            ws = tg._last_worker

            if not (
                ws and tg._last_worker_tasks_left and ws._address in self._workers_dv
            ):
                # Last-used worker is full or unknown; pick a new worker for the next few tasks
                ws = min(
                    (self._idle_dv or self._workers_dv).values(),
                    key=partial(self.worker_objective, ts),
                )
                tg._last_worker_tasks_left = math.floor(
                    (len(tg) / self._total_nthreads) * ws._nthreads
                )

            # Record `last_worker`, or clear it on the final task
            tg._last_worker = (
                ws if tg.states["released"] + tg.states["waiting"] > 1 else None
            )
            tg._last_worker_tasks_left -= 1
            return ws

        if ts._dependencies or valid_workers is not None:
            ws = decide_worker(
                ts,
                self._workers_dv.values(),
                valid_workers,
                partial(self.worker_objective, ts),
            )
        else:
            # Fastpath when there are no related tasks or restrictions
            worker_pool = self._idle or self._workers
            # Note: cython.cast, not typing.cast!
            worker_pool_dv = cast(dict, worker_pool)
            wp_vals = worker_pool.values()
            n_workers: Py_ssize_t = len(worker_pool_dv)
            if n_workers < 20:  # smart but linear in small case
                ws = min(wp_vals, key=operator.attrgetter("occupancy"))
                if ws._occupancy == 0:
                    # special case to use round-robin; linear search
                    # for next worker with zero occupancy (or just
                    # land back where we started).
                    wp_i: WorkerState
                    start: Py_ssize_t = self._n_tasks % n_workers
                    i: Py_ssize_t
                    for i in range(n_workers):
                        wp_i = wp_vals[(i + start) % n_workers]
                        if wp_i._occupancy == 0:
                            ws = wp_i
                            break
            else:  # dumb but fast in large case
                ws = wp_vals[self._n_tasks % n_workers]

        if self._validate:
            assert ws is None or isinstance(ws, WorkerState), (
                type(ws),
                ws,
            )
            assert ws._address in self._workers_dv

        return ws

    @ccall
    def set_duration_estimate(self, ts: TaskState, ws: WorkerState) -> double:
        """Estimate task duration using worker state and task state.

        If a task takes longer than twice the current average duration we
        estimate the task duration to be 2x current-runtime, otherwise we set it
        to be the average duration.

        See also ``_remove_from_processing``
        """
        exec_time: double = ws._executing.get(ts, 0)
        duration: double = self.get_task_duration(ts)
        total_duration: double
        if exec_time > 2 * duration:
            total_duration = 2 * exec_time
        else:
            comm: double = self.get_comm_cost(ts, ws)
            total_duration = duration + comm
        old = ws._processing.get(ts, 0)
        ws._processing[ts] = total_duration

        if ts not in ws._long_running:
            self._total_occupancy += total_duration - old
            ws._occupancy += total_duration - old

        return total_duration

    def transition_waiting_processing(self, key):
        try:
            ts: TaskState = self._tasks[key]
            dts: TaskState
            recommendations: dict = {}
            client_msgs: dict = {}
            worker_msgs: dict = {}

            if self._validate:
                assert not ts._waiting_on
                assert not ts._who_has
                assert not ts._exception_blame
                assert not ts._processing_on
                assert not ts._has_lost_dependencies
                assert ts not in self._unrunnable
                assert all([dts._who_has for dts in ts._dependencies])

            ws: WorkerState = self.decide_worker(ts)
            if ws is None:
                return recommendations, client_msgs, worker_msgs
            worker = ws._address

            self.set_duration_estimate(ts, ws)
            ts._processing_on = ws
            ts.state = "processing"
            self.consume_resources(ts, ws)
            self.check_idle_saturated(ws)
            self._n_tasks += 1

            if ts._actor:
                ws._actors.add(ts)

            # logger.debug("Send job to worker: %s, %s", worker, key)

            worker_msgs[worker] = [self._task_to_msg(ts)]

            return recommendations, client_msgs, worker_msgs
        except Exception as e:
            logger.exception(e)
            if LOG_PDB:
                import pdb

                pdb.set_trace()
            raise

    def transition_waiting_memory(
        self, key, nbytes=None, type=None, typename: str = None, worker=None, **kwargs
    ):
        try:
            ws: WorkerState = self._workers_dv[worker]
            ts: TaskState = self._tasks[key]
            recommendations: dict = {}
            client_msgs: dict = {}
            worker_msgs: dict = {}

            if self._validate:
                assert not ts._processing_on
                assert ts._waiting_on
                assert ts._state == "waiting"

            ts._waiting_on.clear()

            if nbytes is not None:
                ts.set_nbytes(nbytes)

            self.check_idle_saturated(ws)

            self._add_to_memory(
                ts, ws, recommendations, client_msgs, type=type, typename=typename
            )

            if self._validate:
                assert not ts._processing_on
                assert not ts._waiting_on
                assert ts._who_has

            return recommendations, client_msgs, worker_msgs
        except Exception as e:
            logger.exception(e)
            if LOG_PDB:
                import pdb

                pdb.set_trace()
            raise

    def transition_processing_memory(
        self,
        key,
        nbytes=None,
        type=None,
        typename: str = None,
        worker=None,
        startstops=None,
        **kwargs,
    ):
        ws: WorkerState
        wws: WorkerState
        recommendations: dict = {}
        client_msgs: dict = {}
        worker_msgs: dict = {}
        try:
            ts: TaskState = self._tasks[key]

            assert worker
            assert isinstance(worker, str)

            if self._validate:
                assert ts._processing_on
                ws = ts._processing_on
                assert ts in ws._processing
                assert not ts._waiting_on
                assert not ts._who_has, (ts, ts._who_has)
                assert not ts._exception_blame
                assert ts._state == "processing"

            ws = self._workers_dv.get(worker)  # type: ignore
            if ws is None:
                recommendations[key] = "released"
                return recommendations, client_msgs, worker_msgs

            if ws != ts._processing_on:  # someone else has this task
                logger.info(
                    "Unexpected worker completed task. Expected: %s, Got: %s, Key: %s",
                    ts._processing_on,
                    ws,
                    key,
                )
                worker_msgs[ts._processing_on.address] = [
                    {
                        "op": "cancel-compute",
                        "key": key,
                        "reason": "Finished on different worker",
                    }
                ]

            #############################
            # Update Timing Information #
            #############################
            if startstops:
                startstop: dict
                for startstop in startstops:
                    ts._group.add_duration(
                        stop=startstop["stop"],
                        start=startstop["start"],
                        action=startstop["action"],
                    )

            s: set = self._unknown_durations.pop(ts._prefix._name, set())
            tts: TaskState
            steal = self.extensions.get("stealing")
            for tts in s:
                if tts._processing_on:
                    self.set_duration_estimate(tts, tts._processing_on)
                    if steal:
                        steal.recalculate_cost(tts)

            ############################
            # Update State Information #
            ############################
            if nbytes is not None:
                ts.set_nbytes(nbytes)

            self._remove_from_processing(ts)

            self._add_to_memory(
                ts, ws, recommendations, client_msgs, type=type, typename=typename
            )

            if self._validate:
                assert not ts._processing_on
                assert not ts._waiting_on

            return recommendations, client_msgs, worker_msgs
        except Exception as e:
            logger.exception(e)
            if LOG_PDB:
                import pdb

                pdb.set_trace()
            raise

    def transition_memory_released(self, key, safe: bint = False):
        ws: WorkerState
        try:
            ts: TaskState = self._tasks[key]
            dts: TaskState
            recommendations: dict = {}
            client_msgs: dict = {}
            worker_msgs: dict = {}

            if self._validate:
                assert not ts._waiting_on
                assert not ts._processing_on
                if safe:
                    assert not ts._waiters

            if ts._actor:
                for ws in ts._who_has:
                    ws._actors.discard(ts)
                if ts._who_wants:
                    ts._exception_blame = ts
                    ts._exception = "Worker holding Actor was lost"
                    recommendations[ts._key] = "erred"
                    return (
                        recommendations,
                        client_msgs,
                        worker_msgs,
                    )  # don't try to recreate

            for dts in ts._waiters:
                if dts._state in ("no-worker", "processing"):
                    recommendations[dts._key] = "waiting"
                elif dts._state == "waiting":
                    dts._waiting_on.add(ts)

            # XXX factor this out?
            worker_msg = {
                "op": "free-keys",
                "keys": [key],
                "stimulus_id": f"memory-released-{time()}",
            }
            for ws in ts._who_has:
                worker_msgs[ws._address] = [worker_msg]
            self.remove_all_replicas(ts)

            ts.state = "released"

            report_msg = {"op": "lost-data", "key": key}
            cs: ClientState
            for cs in ts._who_wants:
                client_msgs[cs._client_key] = [report_msg]

            if not ts._run_spec:  # pure data
                recommendations[key] = "forgotten"
            elif ts._has_lost_dependencies:
                recommendations[key] = "forgotten"
            elif ts._who_wants or ts._waiters:
                recommendations[key] = "waiting"

            if self._validate:
                assert not ts._waiting_on

            return recommendations, client_msgs, worker_msgs
        except Exception as e:
            logger.exception(e)
            if LOG_PDB:
                import pdb

                pdb.set_trace()
            raise

    def transition_released_erred(self, key):
        try:
            ts: TaskState = self._tasks[key]
            dts: TaskState
            failing_ts: TaskState
            recommendations: dict = {}
            client_msgs: dict = {}
            worker_msgs: dict = {}

            if self._validate:
                with log_errors(pdb=LOG_PDB):
                    assert ts._exception_blame
                    assert not ts._who_has
                    assert not ts._waiting_on
                    assert not ts._waiters

            failing_ts = ts._exception_blame

            for dts in ts._dependents:
                dts._exception_blame = failing_ts
                if not dts._who_has:
                    recommendations[dts._key] = "erred"

            report_msg = {
                "op": "task-erred",
                "key": key,
                "exception": failing_ts._exception,
                "traceback": failing_ts._traceback,
            }
            cs: ClientState
            for cs in ts._who_wants:
                client_msgs[cs._client_key] = [report_msg]

            ts.state = "erred"

            # TODO: waiting data?
            return recommendations, client_msgs, worker_msgs
        except Exception as e:
            logger.exception(e)
            if LOG_PDB:
                import pdb

                pdb.set_trace()
            raise

    def transition_erred_released(self, key):
        try:
            ts: TaskState = self._tasks[key]
            dts: TaskState
            recommendations: dict = {}
            client_msgs: dict = {}
            worker_msgs: dict = {}

            if self._validate:
                with log_errors(pdb=LOG_PDB):
                    assert ts._exception_blame
                    assert not ts._who_has
                    assert not ts._waiting_on
                    assert not ts._waiters

            ts._exception = None
            ts._exception_blame = None
            ts._traceback = None

            for dts in ts._dependents:
                if dts._state == "erred":
                    recommendations[dts._key] = "waiting"

            w_msg = {
                "op": "free-keys",
                "keys": [key],
                "stimulus_id": f"erred-released-{time()}",
            }
            for ws_addr in ts._erred_on:
                worker_msgs[ws_addr] = [w_msg]
            ts._erred_on.clear()

            report_msg = {"op": "task-retried", "key": key}
            cs: ClientState
            for cs in ts._who_wants:
                client_msgs[cs._client_key] = [report_msg]

            ts.state = "released"

            return recommendations, client_msgs, worker_msgs
        except Exception as e:
            logger.exception(e)
            if LOG_PDB:
                import pdb

                pdb.set_trace()
            raise

    def transition_waiting_released(self, key):
        try:
            ts: TaskState = self._tasks[key]
            recommendations: dict = {}
            client_msgs: dict = {}
            worker_msgs: dict = {}

            if self._validate:
                assert not ts._who_has
                assert not ts._processing_on

            dts: TaskState
            for dts in ts._dependencies:
                if ts in dts._waiters:
                    dts._waiters.discard(ts)
                    if not dts._waiters and not dts._who_wants:
                        recommendations[dts._key] = "released"
            ts._waiting_on.clear()

            ts.state = "released"

            if ts._has_lost_dependencies:
                recommendations[key] = "forgotten"
            elif not ts._exception_blame and (ts._who_wants or ts._waiters):
                recommendations[key] = "waiting"
            else:
                ts._waiters.clear()

            return recommendations, client_msgs, worker_msgs
        except Exception as e:
            logger.exception(e)
            if LOG_PDB:
                import pdb

                pdb.set_trace()
            raise

    def transition_processing_released(self, key):
        try:
            ts: TaskState = self._tasks[key]
            dts: TaskState
            recommendations: dict = {}
            client_msgs: dict = {}
            worker_msgs: dict = {}

            if self._validate:
                assert ts._processing_on
                assert not ts._who_has
                assert not ts._waiting_on
                assert self._tasks[key].state == "processing"

            w: str = self._remove_from_processing(ts)
            if w:
                worker_msgs[w] = [
                    {
                        "op": "free-keys",
                        "keys": [key],
                        "stimulus_id": f"processing-released-{time()}",
                    }
                ]

            ts.state = "released"

            if ts._has_lost_dependencies:
                recommendations[key] = "forgotten"
            elif ts._waiters or ts._who_wants:
                recommendations[key] = "waiting"

            if recommendations.get(key) != "waiting":
                for dts in ts._dependencies:
                    if dts._state != "released":
                        dts._waiters.discard(ts)
                        if not dts._waiters and not dts._who_wants:
                            recommendations[dts._key] = "released"
                ts._waiters.clear()

            if self._validate:
                assert not ts._processing_on

            return recommendations, client_msgs, worker_msgs
        except Exception as e:
            logger.exception(e)
            if LOG_PDB:
                import pdb

                pdb.set_trace()
            raise

    def transition_processing_erred(
        self,
        key: str,
        cause: str = None,
        exception=None,
        traceback=None,
        exception_text: str = None,
        traceback_text: str = None,
        worker: str = None,
        **kwargs,
    ):
        ws: WorkerState
        try:
            ts: TaskState = self._tasks[key]
            dts: TaskState
            failing_ts: TaskState
            recommendations: dict = {}
            client_msgs: dict = {}
            worker_msgs: dict = {}

            if self._validate:
                assert cause or ts._exception_blame
                assert ts._processing_on
                assert not ts._who_has
                assert not ts._waiting_on

            if ts._actor:
                ws = ts._processing_on
                ws._actors.remove(ts)

            w = self._remove_from_processing(ts)

            ts._erred_on.add(w or worker)
            if exception is not None:
                ts._exception = exception
                ts._exception_text = exception_text  # type: ignore
            if traceback is not None:
                ts._traceback = traceback
                ts._traceback_text = traceback_text  # type: ignore
            if cause is not None:
                failing_ts = self._tasks[cause]
                ts._exception_blame = failing_ts
            else:
                failing_ts = ts._exception_blame  # type: ignore

            for dts in ts._dependents:
                dts._exception_blame = failing_ts
                recommendations[dts._key] = "erred"

            for dts in ts._dependencies:
                dts._waiters.discard(ts)
                if not dts._waiters and not dts._who_wants:
                    recommendations[dts._key] = "released"

            ts._waiters.clear()  # do anything with this?

            ts.state = "erred"

            report_msg = {
                "op": "task-erred",
                "key": key,
                "exception": failing_ts._exception,
                "traceback": failing_ts._traceback,
            }
            cs: ClientState
            for cs in ts._who_wants:
                client_msgs[cs._client_key] = [report_msg]

            cs = self._clients["fire-and-forget"]
            if ts in cs._wants_what:
                self._client_releases_keys(
                    cs=cs,
                    keys=[key],
                    recommendations=recommendations,
                )

            if self._validate:
                assert not ts._processing_on

            return recommendations, client_msgs, worker_msgs
        except Exception as e:
            logger.exception(e)
            if LOG_PDB:
                import pdb

                pdb.set_trace()
            raise

    def transition_no_worker_released(self, key):
        try:
            ts: TaskState = self._tasks[key]
            dts: TaskState
            recommendations: dict = {}
            client_msgs: dict = {}
            worker_msgs: dict = {}

            if self._validate:
                assert self._tasks[key].state == "no-worker"
                assert not ts._who_has
                assert not ts._waiting_on

            self._unrunnable.remove(ts)
            ts.state = "released"

            for dts in ts._dependencies:
                dts._waiters.discard(ts)

            ts._waiters.clear()

            return recommendations, client_msgs, worker_msgs
        except Exception as e:
            logger.exception(e)
            if LOG_PDB:
                import pdb

                pdb.set_trace()
            raise

    @ccall
    def remove_key(self, key):
        ts: TaskState = self._tasks.pop(key)
        assert ts._state == "forgotten"
        self._unrunnable.discard(ts)
        cs: ClientState
        for cs in ts._who_wants:
            cs._wants_what.remove(ts)
        ts._who_wants.clear()
        ts._processing_on = None
        ts._exception_blame = ts._exception = ts._traceback = None
        self._task_metadata.pop(key, None)

    def transition_memory_forgotten(self, key):
        ws: WorkerState
        try:
            ts: TaskState = self._tasks[key]
            recommendations: dict = {}
            client_msgs: dict = {}
            worker_msgs: dict = {}

            if self._validate:
                assert ts._state == "memory"
                assert not ts._processing_on
                assert not ts._waiting_on
                if not ts._run_spec:
                    # It's ok to forget a pure data task
                    pass
                elif ts._has_lost_dependencies:
                    # It's ok to forget a task with forgotten dependencies
                    pass
                elif not ts._who_wants and not ts._waiters and not ts._dependents:
                    # It's ok to forget a task that nobody needs
                    pass
                else:
                    assert 0, (ts,)

            if ts._actor:
                for ws in ts._who_has:
                    ws._actors.discard(ts)

            self._propagate_forgotten(ts, recommendations, worker_msgs)

            client_msgs = self._task_to_client_msgs(ts)
            self.remove_key(key)

            return recommendations, client_msgs, worker_msgs
        except Exception as e:
            logger.exception(e)
            if LOG_PDB:
                import pdb

                pdb.set_trace()
            raise

    def transition_released_forgotten(self, key):
        try:
            ts: TaskState = self._tasks[key]
            recommendations: dict = {}
            client_msgs: dict = {}
            worker_msgs: dict = {}

            if self._validate:
                assert ts._state in ("released", "erred")
                assert not ts._who_has
                assert not ts._processing_on
                assert not ts._waiting_on, (ts, ts._waiting_on)
                if not ts._run_spec:
                    # It's ok to forget a pure data task
                    pass
                elif ts._has_lost_dependencies:
                    # It's ok to forget a task with forgotten dependencies
                    pass
                elif not ts._who_wants and not ts._waiters and not ts._dependents:
                    # It's ok to forget a task that nobody needs
                    pass
                else:
                    assert 0, (ts,)

            self._propagate_forgotten(ts, recommendations, worker_msgs)

            client_msgs = self._task_to_client_msgs(ts)
            self.remove_key(key)

            return recommendations, client_msgs, worker_msgs
        except Exception as e:
            logger.exception(e)
            if LOG_PDB:
                import pdb

                pdb.set_trace()
            raise

    ##############################
    # Assigning Tasks to Workers #
    ##############################

    @ccall
    @exceptval(check=False)
    def check_idle_saturated(self, ws: WorkerState, occ: double = -1.0):
        """Update the status of the idle and saturated state

        The scheduler keeps track of workers that are ..

        -  Saturated: have enough work to stay busy
        -  Idle: do not have enough work to stay busy

        They are considered saturated if they both have enough tasks to occupy
        all of their threads, and if the expected runtime of those tasks is
        large enough.

        This is useful for load balancing and adaptivity.
        """
        if self._total_nthreads == 0 or ws.status == Status.closed:
            return
        if occ < 0:
            occ = ws._occupancy

        nc: Py_ssize_t = ws._nthreads
        p: Py_ssize_t = len(ws._processing)
        avg: double = self._total_occupancy / self._total_nthreads

        idle = self._idle
        saturated: set = self._saturated
        if p < nc or occ < nc * avg / 2:
            idle[ws._address] = ws
            saturated.discard(ws)
        else:
            idle.pop(ws._address, None)

            if p > nc:
                pending: double = occ * (p - nc) / (p * nc)
                if 0.4 < pending > 1.9 * avg:
                    saturated.add(ws)
                    return

            saturated.discard(ws)

    @ccall
    def get_comm_cost(self, ts: TaskState, ws: WorkerState) -> double:
        """
        Get the estimated communication cost (in s.) to compute the task
        on the given worker.
        """
        dts: TaskState
        deps: set = ts._dependencies.difference(ws._has_what)
        nbytes: Py_ssize_t = 0
        for dts in deps:
            nbytes += dts._nbytes
        return nbytes / self._bandwidth

    @ccall
    def get_task_duration(self, ts: TaskState) -> double:
        """Get the estimated computation cost of the given task (not including
        any communication cost).

        If no data has been observed, value of
        `distributed.scheduler.default-task-durations` are used. If none is set
        for this task, `distributed.scheduler.unknown-task-duration` is used
        instead.
        """
        duration: double = ts._prefix._duration_average
        if duration >= 0:
            return duration

        s: set = self._unknown_durations.get(ts._prefix._name)  # type: ignore
        if s is None:
            self._unknown_durations[ts._prefix._name] = s = set()
        s.add(ts)
        return self._UNKNOWN_TASK_DURATION

    @ccall
    @exceptval(check=False)
    def valid_workers(self, ts: TaskState) -> set:  # set[WorkerState] | None
        """Return set of currently valid workers for key

        If all workers are valid then this returns ``None``.
        This checks tracks the following state:

        *  worker_restrictions
        *  host_restrictions
        *  resource_restrictions
        """
        s: set = None  # type: ignore

        if ts._worker_restrictions:
            s = {addr for addr in ts._worker_restrictions if addr in self._workers_dv}

        if ts._host_restrictions:
            # Resolve the alias here rather than early, for the worker
            # may not be connected when host_restrictions is populated
            hr: list = [self.coerce_hostname(h) for h in ts._host_restrictions]
            # XXX need HostState?
            sl: list = []
            for h in hr:
                dh: dict = self._host_info.get(h)  # type: ignore
                if dh is not None:
                    sl.append(dh["addresses"])

            ss: set = set.union(*sl) if sl else set()
            if s is None:
                s = ss
            else:
                s |= ss

        if ts._resource_restrictions:
            dw: dict = {}
            for resource, required in ts._resource_restrictions.items():
                dr: dict = self._resources.get(resource)  # type: ignore
                if dr is None:
                    self._resources[resource] = dr = {}

                sw: set = set()
                for addr, supplied in dr.items():
                    if supplied >= required:
                        sw.add(addr)

                dw[resource] = sw

            ww: set = set.intersection(*dw.values())
            if s is None:
                s = ww
            else:
                s &= ww

        if s is None:
            if len(self._running) < len(self._workers_dv):
                return self._running.copy()
        else:
            s = {self._workers_dv[addr] for addr in s}
            if len(self._running) < len(self._workers_dv):
                s &= self._running

        return s

    @ccall
    def consume_resources(self, ts: TaskState, ws: WorkerState):
        if ts._resource_restrictions:
            for r, required in ts._resource_restrictions.items():
                ws._used_resources[r] += required

    @ccall
    def release_resources(self, ts: TaskState, ws: WorkerState):
        if ts._resource_restrictions:
            for r, required in ts._resource_restrictions.items():
                ws._used_resources[r] -= required

    @ccall
    def coerce_hostname(self, host):
        """
        Coerce the hostname of a worker.
        """
        alias = self._aliases.get(host)
        if alias is not None:
            ws: WorkerState = self._workers_dv[alias]
            return ws.host
        else:
            return host

    @ccall
    @exceptval(check=False)
    def worker_objective(self, ts: TaskState, ws: WorkerState) -> tuple:
        """
        Objective function to determine which worker should get the task

        Minimize expected start time.  If a tie then break with data storage.
        """
        dts: TaskState
        nbytes: Py_ssize_t
        comm_bytes: Py_ssize_t = 0
        for dts in ts._dependencies:
            if ws not in dts._who_has:
                nbytes = dts.get_nbytes()
                comm_bytes += nbytes

        stack_time: double = ws._occupancy / ws._nthreads
        start_time: double = stack_time + comm_bytes / self._bandwidth

        if ts._actor:
            return (len(ws._actors), start_time, ws._nbytes)
        else:
            return (start_time, ws._nbytes)

    @ccall
    def add_replica(self, ts: TaskState, ws: WorkerState):
        """Note that a worker holds a replica of a task with state='memory'"""
        if self._validate:
            assert ws not in ts._who_has
            assert ts not in ws._has_what

        ws._nbytes += ts.get_nbytes()
        ws._has_what[ts] = None
        ts._who_has.add(ws)
        if len(ts._who_has) == 2:
            self._replicated_tasks.add(ts)

    @ccall
    def remove_replica(self, ts: TaskState, ws: WorkerState):
        """Note that a worker no longer holds a replica of a task"""
        ws._nbytes -= ts.get_nbytes()
        del ws._has_what[ts]
        ts._who_has.remove(ws)
        if len(ts._who_has) == 1:
            self._replicated_tasks.remove(ts)

    @ccall
    def remove_all_replicas(self, ts: TaskState):
        """Remove all replicas of a task from all workers"""
        ws: WorkerState
        nbytes: Py_ssize_t = ts.get_nbytes()
        for ws in ts._who_has:
            ws._nbytes -= nbytes
            del ws._has_what[ts]
        if len(ts._who_has) > 1:
            self._replicated_tasks.remove(ts)
        ts._who_has.clear()

    @ccall
    @exceptval(check=False)
    def reevaluate_occupancy_worker(self, ws: WorkerState):
        """See reevaluate_occupancy"""
        ts: TaskState
        old = ws._occupancy
        for ts in ws._processing:
            self.set_duration_estimate(ts, ws)

        self.check_idle_saturated(ws)
        steal = self.extensions.get("stealing")
        if steal is None:
            return
        if ws._occupancy > old * 1.3 or old > ws._occupancy * 1.3:
            for ts in ws._processing:
                steal.recalculate_cost(ts)

    ###################
    # Task Validation #
    ###################
    # TODO: could all be @ccall, but called rarely

    def validate_released(self, key):
        ts: TaskState = self._tasks[key]
        dts: TaskState
        assert ts._state == "released"
        assert not ts._waiters
        assert not ts._waiting_on
        assert not ts._who_has
        assert not ts._processing_on
        assert not any([ts in dts._waiters for dts in ts._dependencies])
        assert ts not in self._unrunnable

    def validate_waiting(self, key):
        ts: TaskState = self._tasks[key]
        dts: TaskState
        assert ts._waiting_on
        assert not ts._who_has
        assert not ts._processing_on
        assert ts not in self._unrunnable
        for dts in ts._dependencies:
            # We are waiting on a dependency iff it's not stored
            assert (not not dts._who_has) != (dts in ts._waiting_on)
            assert ts in dts._waiters  # XXX even if dts._who_has?

    def validate_processing(self, key):
        ts: TaskState = self._tasks[key]
        dts: TaskState
        assert not ts._waiting_on
        ws: WorkerState = ts._processing_on
        assert ws
        assert ts in ws._processing
        assert not ts._who_has
        for dts in ts._dependencies:
            assert dts._who_has
            assert ts in dts._waiters

    def validate_memory(self, key):
        ts: TaskState = self._tasks[key]
        dts: TaskState
        assert ts._who_has
        assert bool(ts in self._replicated_tasks) == (len(ts._who_has) > 1)
        assert not ts._processing_on
        assert not ts._waiting_on
        assert ts not in self._unrunnable
        for dts in ts._dependents:
            assert (dts in ts._waiters) == (dts._state in ("waiting", "processing"))
            assert ts not in dts._waiting_on

    def validate_no_worker(self, key):
        ts: TaskState = self._tasks[key]
        dts: TaskState
        assert ts in self._unrunnable
        assert not ts._waiting_on
        assert not ts._processing_on
        assert not ts._who_has
        for dts in ts._dependencies:
            assert dts._who_has

    def validate_erred(self, key):
        ts: TaskState = self._tasks[key]
        assert ts._exception_blame
        assert not ts._who_has

    def validate_key(self, key, ts: TaskState = None):
        try:
            if ts is None:
                ts = self._tasks.get(key)
            if ts is None:
                logger.debug("Key lost: %s", key)
            else:
                ts.validate()
                try:
                    func = getattr(self, "validate_" + ts._state.replace("-", "_"))
                except AttributeError:
                    logger.error(
                        "self.validate_%s not found", ts._state.replace("-", "_")
                    )
                else:
                    func(key)
        except Exception as e:
            logger.exception(e)
            if LOG_PDB:
                import pdb

                pdb.set_trace()
            raise

    def validate_state(self, allow_overlap=False):
        validate_state(self._tasks, self._workers, self._clients)

        # if not (set(self.state.workers) == set(self.stream_comms)):
        #    raise ValueError("Workers not the same in all collections")

        ws: WorkerState
        for w, ws in self._workers_dv.items():
            assert isinstance(w, str), (type(w), w)
            assert isinstance(ws, WorkerState), (type(ws), ws)
            assert ws._address == w
            if not ws._processing:
                assert not ws._occupancy
                assert ws._address in self._idle_dv

        ts: TaskState
        for k, ts in self._tasks.items():
            assert isinstance(ts, TaskState), (type(ts), ts)
            assert ts._key == k
            self.validate_key(k, ts)

        c: str
        cs: ClientState
        for c, cs in self._clients.items():
            # client=None is often used in tests...
            assert c is None or type(c) == str, (type(c), c)
            assert type(cs) == ClientState, (type(cs), cs)
            assert cs._client_key == c

        a = {w: ws._nbytes for w, ws in self._workers_dv.items()}
        b = {
            w: sum(ts.get_nbytes() for ts in ws._has_what)
            for w, ws in self._workers_dv.items()
        }
        assert a == b, (a, b)

        actual_total_occupancy = 0
        for worker, ws in self._workers_dv.items():
            assert abs(sum(ws._processing.values()) - ws._occupancy) < 1e-8
            actual_total_occupancy += ws._occupancy

        assert abs(actual_total_occupancy - self._total_occupancy) < 1e-8, (
            actual_total_occupancy,
            self._total_occupancy,
        )


@ccall
def validate_worker_state(ws: WorkerState):
    ts: TaskState
    for ts in ws._has_what:
        assert ws in ts._who_has, (
            "not in has_what' who_has",
            str(ws),
            str(ts),
            str(ts._who_has),
        )

    for ts in ws._actors:
        assert ts._state in ("memory", "processing")


@ccall
def validate_state(tasks, workers, clients):
    """
    Validate a current runtime state

    This performs a sequence of checks on the entire graph, running in about
    linear time.  This raises assert errors if anything doesn't check out.
    """
    ts: TaskState
    for ts in tasks.values():
        validate_task_state(ts)

    ws: WorkerState
    for ws in workers.values():
        validate_worker_state(ws)

    cs: ClientState
    for cs in clients.values():
        for ts in cs._wants_what:
            assert cs in ts._who_wants, (
                "not in wants_what' who_wants",
                str(cs),
                str(ts),
                str(ts._who_wants),
            )


@ccall
def validate_task_state(ts: TaskState):
    """
    Validate the given TaskState.
    """
    ws: WorkerState
    dts: TaskState

    assert ts._state in ALL_TASK_STATES or ts._state == "forgotten", ts

    if ts._waiting_on:
        assert ts._waiting_on.issubset(ts._dependencies), (
            "waiting not subset of dependencies",
            str(ts._waiting_on),
            str(ts._dependencies),
        )
    if ts._waiters:
        assert ts._waiters.issubset(ts._dependents), (
            "waiters not subset of dependents",
            str(ts._waiters),
            str(ts._dependents),
        )

    for dts in ts._waiting_on:
        assert not dts._who_has, ("waiting on in-memory dep", str(ts), str(dts))
        assert dts._state != "released", ("waiting on released dep", str(ts), str(dts))
    for dts in ts._dependencies:
        assert ts in dts._dependents, (
            "not in dependency's dependents",
            str(ts),
            str(dts),
            str(dts._dependents),
        )
        if ts._state in ("waiting", "processing"):
            assert dts in ts._waiting_on or dts._who_has, (
                "dep missing",
                str(ts),
                str(dts),
            )
        assert dts._state != "forgotten"

    for dts in ts._waiters:
        assert dts._state in ("waiting", "processing"), (
            "waiter not in play",
            str(ts),
            str(dts),
        )
    for dts in ts._dependents:
        assert ts in dts._dependencies, (
            "not in dependent's dependencies",
            str(ts),
            str(dts),
            str(dts._dependencies),
        )
        assert dts._state != "forgotten"

    assert (ts._processing_on is not None) == (ts._state == "processing")
    assert bool(ts._who_has) == (ts._state == "memory"), (ts, ts._who_has)

    if ts._state == "processing":
        assert all([dts._who_has for dts in ts._dependencies]), (
            "task processing without all deps",
            str(ts),
            str(ts._dependencies),
        )
        assert not ts._waiting_on

    if ts._who_has:
        assert ts._waiters or ts._who_wants, (
            "unneeded task in memory",
            str(ts),
            str(ts._who_has),
        )
        if ts._run_spec:  # was computed
            assert ts._type
            assert isinstance(ts._type, str)
        assert not any([ts in dts._waiting_on for dts in ts._dependents])
        for ws in ts._who_has:
            assert ts in ws._has_what, (
                "not in who_has' has_what",
                str(ts),
                str(ws),
                str(ws._has_what),
            )

    if ts._who_wants:
        cs: ClientState
        for cs in ts._who_wants:
            assert ts in cs._wants_what, (
                "not in who_wants' wants_what",
                str(ts),
                str(cs),
                str(cs._wants_what),
            )

    if ts._actor:
        if ts._state == "memory":
            assert sum([ts in ws._actors for ws in ts._who_has]) == 1
        if ts._state == "processing":
            assert ts in ts._processing_on.actors


@cfunc
@exceptval(check=False)
def decide_worker(
    ts: TaskState, all_workers, valid_workers: set, objective
) -> WorkerState:  # -> WorkerState | None
    """
    Decide which worker should take task *ts*.

    We choose the worker that has the data on which *ts* depends.

    If several workers have dependencies then we choose the less-busy worker.

    Optionally provide *valid_workers* of where jobs are allowed to occur
    (if all workers are allowed to take the task, pass None instead).

    If the task requires data communication because no eligible worker has
    all the dependencies already, then we choose to minimize the number
    of bytes sent between workers.  This is determined by calling the
    *objective* function.
    """
    ws: WorkerState = None  # type: ignore
    wws: WorkerState
    dts: TaskState
    deps: set = ts._dependencies
    candidates: set
    assert all([dts._who_has for dts in deps])
    if ts._actor:
        candidates = set(all_workers)
    else:
        candidates = {wws for dts in deps for wws in dts._who_has}
    if valid_workers is None:
        if not candidates:
            candidates = set(all_workers)
    else:
        candidates &= valid_workers
        if not candidates:
            candidates = valid_workers
            if not candidates:
                if ts._loose_restrictions:
                    ws = decide_worker(ts, all_workers, None, objective)
                return ws

    ncandidates: Py_ssize_t = len(candidates)
    if ncandidates == 0:
        pass
    elif ncandidates == 1:
        for ws in candidates:
            break
    else:
        ws = min(candidates, key=objective)
    return ws
